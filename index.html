<!DOCTYPE html>
<html lang="ar">
<head>
  <meta charset="UTF-8" />
  <title>Roblox Style Oilfield Training</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{
      background:#020617;
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif;
      color:#f9fafb;
      overflow:hidden;
      direction:rtl;
    }
    #layout{
      display:flex;
      width:100vw;
      height:100vh;
    }
    #game-wrapper{
      flex:1 1 auto;
      position:relative;
      background:#020617;
    }
    /* Three.js canvas يأخذ كل المساحة */
    #three-container{
      position:absolute;
      inset:0;
    }

    /* HUD */
    #hud{
      position:absolute;
      top:8px;
      left:50%;
      transform:translateX(-50%);
      background:rgba(15,23,42,.92);
      border-radius:999px;
      padding:6px 14px;
      font-size:11px;
      border:1px solid rgba(148,163,184,.5);
      white-space:nowrap;
      z-index:5;
    }
    #hint{
      position:absolute;
      bottom:8px;
      right:8px;
      background:rgba(15,23,42,.92);
      border-radius:12px;
      padding:6px 10px;
      font-size:11px;
      border:1px solid rgba(148,163,184,.5);
      max-width:260px;
      z-index:5;
    }

    /* أزرار لمس (ستايل روبلوكس بسيط) */
    #touch-controls{
      position:absolute;
      bottom:14px;
      left:50%;
      transform:translateX(-50%);
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:6px;
      z-index:6;
      pointer-events:auto;
    }
    .tc-row{display:flex;gap:6px}
    .tc-btn{
      width:52px;
      height:52px;
      border-radius:12px;
      border:2px solid #111827;
      background:linear-gradient(145deg,#111827,#020617);
      color:#e5e7eb;
      font-size:22px;
      box-shadow:0 4px 10px rgba(0,0,0,.9);
      touch-action:none;
      cursor:pointer;
    }
    .tc-btn:active{
      background:linear-gradient(145deg,#1d4ed8,#020617);
    }
    .tc-btn-small{
      width:90px;
      font-size:13px;
    }

    /* لوحة جانبية – بيانات البئر + bean */
    #ui-panel{
      width:340px;
      max-width:40vw;
      background:radial-gradient(circle at top,#020617,#020617 60%,#040b1a 100%);
      border-left:2px solid #1d4ed8;
      display:flex;
      flex-direction:column;
      padding:14px 12px;
      gap:10px;
    }
    .card{
      background:rgba(15,23,42,.95);
      border-radius:14px;
      border:1px solid rgba(148,163,184,.4);
      padding:8px 10px;
      font-size:12px;
    }
    .card h3{font-size:13px;margin-bottom:6px}
    .grid2{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:6px;
    }
    .stat-box{
      background:#020617;
      border-radius:10px;
      border:1px solid #1f2937;
      padding:6px;
    }
    .stat-label{font-size:11px;opacity:.8}
    .stat-value{
      font-size:16px;
      font-weight:700;
      margin-top:2px;
      text-shadow:0 0 6px rgba(59,130,246,.9);
    }
    .tag{
      display:inline-block;
      font-size:11px;
      padding:2px 8px;
      border-radius:999px;
      margin-top:4px;
    }
    .tag-ok{background:rgba(22,163,74,.18);color:#bbf7d0;border:1px solid #22c55e}
    .tag-bad{background:rgba(248,113,113,.18);color:#fecaca;border:1px solid #f87171}
    #well-name{font-weight:600;font-size:14px;margin-bottom:4px}
    .btn{
      border-radius:999px;
      border:none;
      padding:7px 10px;
      font-size:12px;
      font-weight:600;
      cursor:pointer;
      margin-top:4px;
      width:100%;
    }
    #btn-open{background:linear-gradient(90deg,#38bdf8,#6366f1);color:#fff}
    #btn-clean{background:linear-gradient(90deg,#22c55e,#a3e635);color:#052e16}
    #btn-clean.disabled{filter:grayscale(.9);opacity:.6;cursor:default}

    /* bean الواقعي */
    #bean-card{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:6px;
    }
    #bean-title{font-size:13px;font-weight:600;margin-bottom:2px}
    #bean-visual{
      width:140px;
      height:140px;
      border-radius:50%;
      border:5px solid #9ca3af;
      box-shadow:0 0 15px rgba(0,0,0,.9) inset;
      background-color:#020617;
      background-position:center;
      background-size:cover;
      margin:4px auto;
    }
    .bean-dirty{background-image:url("bean_blockage.jpg")}
    .bean-clean{background-image:url("bean_clean.jpg")}
    #bean-note{
      font-size:10px;
      opacity:.9;
      text-align:center;
      line-height:1.4;
    }

    #log{font-size:11px;max-height:160px;overflow-y:auto}
    #log p{margin-bottom:3px}

    @media(max-width:900px){
      #ui-panel{width:280px;padding:10px 8px}
      #hud{font-size:9px;padding:5px 10px}
    }
  </style>
</head>
<body>
  <div id="layout">
    <div id="game-wrapper">
      <div id="three-container"></div>

      <div id="hud">
        كمبيوتر: W/S للأمام والخلف، A/D للّف – E فحص، C تنظيف. موبايل: الأسهم + أزرار الفحص والتنظيف.
      </div>
      <div id="hint">
        عالم 3D بأسلوب Roblox. تحرك في الصحراء، اقترب من بئر، ثم اضغط <b>E</b> أو زر <b>فحص</b>
        لقراءة WHP/FLP وفتح ADJ BEAN. ستشاهد شكل الـ bean الحقيقي (blockage / clean) في اللوحة الجانبية.
      </div>

      <div id="touch-controls">
        <div class="tc-row">
          <button id="tc-up" class="tc-btn">↑</button>
        </div>
        <div class="tc-row">
          <button id="tc-left" class="tc-btn">←</button>
          <button id="tc-down" class="tc-btn">↓</button>
          <button id="tc-right" class="tc-btn">→</button>
        </div>
        <div class="tc-row">
          <button id="tc-inspect" class="tc-btn tc-btn-small">E فحص</button>
          <button id="tc-clean" class="tc-btn tc-btn-small">C تنظيف</button>
        </div>
      </div>
    </div>

    <aside id="ui-panel">
      <div class="card">
        <div id="well-name">لم يتم اختيار بئر</div>
        <div class="grid2">
          <div class="stat-box">
            <div class="stat-label">WHP (psi)</div>
            <div id="whp-val" class="stat-value">---</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">FLP (psi)</div>
            <div id="flp-val" class="stat-value">---</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">CASING</div>
            <div id="casing-val" class="stat-value">Closed</div>
          </div>
          <div class="stat-box">
            <div class="stat-label">حالة البئر</div>
            <div id="state-val" class="stat-value">غير مفحوص</div>
            <div id="state-tag" class="tag tag-ok">Normal</div>
          </div>
        </div>
        <button id="btn-open" class="btn">فتح ADJ BEAN وقراءة الحالة</button>
        <button id="btn-clean" class="btn disabled">تنظيف الـ blockage من ADJ BEAN</button>
      </div>

      <div class="card" id="bean-card">
        <div id="bean-title">منظر البين من الداخل</div>
        <div id="bean-visual"></div>
        <div id="bean-note">
          عند فتح ADJ BEAN يتم عرض صورة للـ bean من الداخل.<br>
          إذا كان فيه ترسبات → Blockage. بعد التنظيف يظهر نظيف مثل الصورة الواقعية.
        </div>
      </div>

      <div class="card">
        <h3>Training Objectives</h3>
        <ul style="padding-right:18px;line-height:1.4;">
          <li>التحرك في حقل 3D بأسلوب Roblox والوصول لعدة آبار.</li>
          <li>قراءة WHP / FLP وتحديد وجود Blockage.</li>
          <li>رؤية البين الواقعي (مسدود / نظيف) عند فتح ADJ BEAN.</li>
          <li>تنظيف الـ blockage وملاحظة تغيّر القراءات وشكل البين.</li>
        </ul>
      </div>

      <div class="card">
        <h3>Log</h3>
        <div id="log"></div>
      </div>
    </aside>
  </div>

  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
  <script>
    // ====== Three.js Setup (Roblox-style block world) ======
    const container = document.getElementById("three-container");
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87c8ff);

    const camera = new THREE.PerspectiveCamera(
      60,
      container.clientWidth / container.clientHeight,
      0.1,
      2000
    );

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.shadowMap.enabled = true;
    container.appendChild(renderer.domElement);

    function onResize() {
      const w = container.clientWidth;
      const h = container.clientHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    }
    window.addEventListener("resize", onResize);

    const hemiLight = new THREE.HemisphereLight(0xffffff, 0xe0bb7f, 0.9);
    scene.add(hemiLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
    dirLight.position.set(80, 120, -40);
    dirLight.castShadow = true;
    scene.add(dirLight);

    // أرضية بلوكية
    const groundGeo = new THREE.PlaneGeometry(4000, 4000);
    const groundMat = new THREE.MeshStandardMaterial({ color: 0xf0c27b });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    // بلاطات مربعة لإحساس Roblox
    const tileGeo = new THREE.PlaneGeometry(40, 40);
    const tileMat = new THREE.MeshStandardMaterial({ color: 0xeab676 });
    for (let x = -400; x <= 400; x += 40) {
      for (let z = -400; z <= 400; z += 40) {
        const tile = new THREE.Mesh(tileGeo, tileMat);
        tile.rotation.x = -Math.PI / 2;
        tile.position.set(x, 0.01, z);
        tile.receiveShadow = true;
        scene.add(tile);
      }
    }

    // عامل Roblox-style (body + head + arms)
    const playerGroup = new THREE.Group();

    const bodyGeo = new THREE.BoxGeometry(8, 10, 4);
    const bodyMat = new THREE.MeshStandardMaterial({ color: 0xffd54f });
    const body = new THREE.Mesh(bodyGeo, bodyMat);
    body.castShadow = true;
    body.position.y = 8;
    playerGroup.add(body);

    const headGeo = new THREE.BoxGeometry(6, 6, 6);
    const headMat = new THREE.MeshStandardMaterial({ color: 0xffe0b2 });
    const head = new THREE.Mesh(headGeo, headMat);
    head.castShadow = true;
    head.position.y = 14;
    playerGroup.add(head);

    const helmetGeo = new THREE.BoxGeometry(7, 2, 7);
    const helmetMat = new THREE.MeshStandardMaterial({ color: 0xfb923c });
    const helmet = new THREE.Mesh(helmetGeo, helmetMat);
    helmet.castShadow = true;
    helmet.position.y = 17;
    playerGroup.add(helmet);

    const legGeo = new THREE.BoxGeometry(3, 8, 3);
    const legMat = new THREE.MeshStandardMaterial({ color: 0x1d4ed8 });
    const legL = new THREE.Mesh(legGeo, legMat);
    legL.position.set(-2, 4, 0);
    const legR = legL.clone();
    legR.position.x = 2;
    playerGroup.add(legL, legR);

    playerGroup.position.set(60, 0, -40);
    scene.add(playerGroup);

    // آبار كبلوكات ثلاثية الأبعاد
    function createRobloxWell(colorBase) {
      const g = new THREE.Group();

      const baseGeo = new THREE.BoxGeometry(10, 2, 10);
      const baseMat = new THREE.MeshStandardMaterial({ color: 0x4b5563 });
      const base = new THREE.Mesh(baseGeo, baseMat);
      base.position.y = 1;
      base.castShadow = true;
      base.receiveShadow = true;
      g.add(base);

      const stemGeo = new THREE.BoxGeometry(3, 12, 3);
      const stemMat = new THREE.MeshStandardMaterial({ color: colorBase });
      const stem = new THREE.Mesh(stemGeo, stemMat);
      stem.position.y = 7;
      stem.castShadow = true;
      g.add(stem);

      const armGeo = new THREE.BoxGeometry(10, 2, 2);
      const arm = new THREE.Mesh(armGeo, stemMat);
      arm.position.set(6.5, 9, 0);
      arm.castShadow = true;
      g.add(arm);

      const chokeGeo = new THREE.BoxGeometry(3, 3, 3);
      const chokeMat = new THREE.MeshStandardMaterial({ color: 0x22c55e });
      const choke = new THREE.Mesh(chokeGeo, chokeMat);
      choke.position.set(11, 9, 0);
      choke.castShadow = true;
      choke.name = "choke";
      g.add(choke);

      return g;
    }

    const wellsData = [
      { id: "AH-0117", pos: new THREE.Vector3(80, 0, -40), blockage: true, cleaned: false },
      { id: "AH-0216", pos: new THREE.Vector3(-60, 0, -50), blockage: false, cleaned: false },
      { id: "AH-0274", pos: new THREE.Vector3(140, 0, 60), blockage: true, cleaned: false },
      { id: "AH-0287", pos: new THREE.Vector3(-140, 0, 120), blockage: true, cleaned: false },
      { id: "MG-0345", pos: new THREE.Vector3(40, 0, 150), blockage: false, cleaned: false }
    ];

    wellsData.forEach(w => {
      const m = createRobloxWell(0x1d4ed8);
      m.position.copy(w.pos);
      m.userData.id = w.id;
      m.userData.blockage = w.blockage;
      m.userData.cleaned = w.cleaned;
      scene.add(m);
      w.mesh = m;
    });

    // حركة اللاعب (ستايل روبلوكس بسيط)
    let yaw = 0;
    const keys = { forward:false, backward:false, left:false, right:false };

    window.addEventListener("keydown", e => {
      if (e.code === "KeyW" || e.code === "ArrowUp") keys.forward = true;
      if (e.code === "KeyS" || e.code === "ArrowDown") keys.backward = true;
      if (e.code === "KeyA" || e.code === "ArrowLeft") keys.left = true;
      if (e.code === "KeyD" || e.code === "ArrowRight") keys.right = true;
      if (e.code === "KeyE") inspectNearest();
      if (e.code === "KeyC") cleanCurrent();
    });
    window.addEventListener("keyup", e => {
      if (e.code === "KeyW" || e.code === "ArrowUp") keys.forward = false;
      if (e.code === "KeyS" || e.code === "ArrowDown") keys.backward = false;
      if (e.code === "KeyA" || e.code === "ArrowLeft") keys.left = false;
      if (e.code === "KeyD" || e.code === "ArrowRight") keys.right = false;
    });

    function bindTouch(btnId, keyName){
      const btn = document.getElementById(btnId);
      if (!btn) return;
      const start = e => { e.preventDefault(); keys[keyName] = true; };
      const end   = e => { e.preventDefault(); keys[keyName] = false; };
      btn.addEventListener("touchstart", start,{passive:false});
      btn.addEventListener("touchend",   end,  {passive:false});
      btn.addEventListener("touchcancel",end,  {passive:false});
      btn.addEventListener("mousedown",  start);
      window.addEventListener("mouseup", end);
    }
    bindTouch("tc-up","forward");
    bindTouch("tc-down","backward");
    bindTouch("tc-left","left");
    bindTouch("tc-right","right");

    document.getElementById("tc-inspect")
      .addEventListener("click", () => inspectNearest());
    document.getElementById("tc-inspect")
      .addEventListener("touchstart", e => { e.preventDefault(); inspectNearest(); });
    document.getElementById("tc-clean")
      .addEventListener("click", () => cleanCurrent());
    document.getElementById("tc-clean")
      .addEventListener("touchstart", e => { e.preventDefault(); cleanCurrent(); });

    function updatePlayer(delta){
      const turnSpeed = 1.8 * delta;
      const moveSpeed = 40 * delta;

      if (keys.left)  yaw += turnSpeed;
      if (keys.right) yaw -= turnSpeed;

      const dir = new THREE.Vector3(Math.sin(yaw), 0, -Math.cos(yaw));

      if (keys.forward)  playerGroup.position.addScaledVector(dir, moveSpeed);
      if (keys.backward) playerGroup.position.addScaledVector(dir, -moveSpeed);

      // كاميرا خلف اللاعب
      const camOffset = new THREE.Vector3(0, 25, 40);
      camOffset.applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
      camera.position.copy(playerGroup.position).add(camOffset);
      camera.lookAt(playerGroup.position.clone().add(new THREE.Vector3(0,12,0)));
    }

    // ====== منطق التدريب / اللوحة الجانبية ======
    const wellNameEl = document.getElementById("well-name");
    const whpEl      = document.getElementById("whp-val");
    const flpEl      = document.getElementById("flp-val");
    const casingEl   = document.getElementById("casing-val");
    const stateEl    = document.getElementById("state-val");
    const stateTag   = document.getElementById("state-tag");
    const btnOpen    = document.getElementById("btn-open");
    const btnClean   = document.getElementById("btn-clean");
    const logEl      = document.getElementById("log");
    const beanVisual = document.getElementById("bean-visual");

    let currentWell = null;

    function log(msg){
      const p=document.createElement("p");
      p.textContent=msg;
      logEl.prepend(p);
    }

    function calcPressures(well){
      if (well.userData.blockage && !well.userData.cleaned){
        return {
          whp: 420 + Math.floor(Math.random()*20),
          flp: 120 + Math.floor(Math.random()*15),
          bad: true,
          text:"Blockage محتمل / مؤكد"
        };
      } else {
        return {
          whp: 260 + Math.floor(Math.random()*15),
          flp: 240 + Math.floor(Math.random()*15),
          bad:false,
          text:"تدفق طبيعي"
        };
      }
    }

    function updateBeanVisual(well){
      beanVisual.classList.remove("bean-dirty","bean-clean");
      if (!well) return;
      if (well.userData.blockage && !well.userData.cleaned){
        beanVisual.classList.add("bean-dirty");
      } else {
        beanVisual.classList.add("bean-clean");
      }
    }

    function updateUIForWell(well){
      if (!well){
        wellNameEl.textContent="لم يتم اختيار بئر";
        whpEl.textContent="---";
        flpEl.textContent="---";
        casingEl.textContent="Closed";
        stateEl.textContent="غير مفحوص";
        stateTag.textContent="Normal";
        stateTag.className="tag tag-ok";
        btnClean.classList.add("disabled");
        updateBeanVisual(null);
        return;
      }
      const p = calcPressures(well);
      wellNameEl.textContent="بئر "+well.userData.id;
      whpEl.textContent=p.whp+" psi";
      flpEl.textContent=p.flp+" psi";
      casingEl.textContent="Closed";
      stateEl.textContent=p.text;
      if (p.bad){
        stateTag.textContent="Blockage";
        stateTag.className="tag tag-bad";
        btnClean.classList.remove("disabled");
      }else{
        stateTag.textContent="Normal";
        stateTag.className="tag tag-ok";
        btnClean.classList.add("disabled");
      }
      updateBeanVisual(well);
    }

    function nearestWell(){
      let best=null;
      let bestDist=30; // متر تقريبي في اللعبة
      const p=playerGroup.position;
      wellsData.forEach(w=>{
        const d=p.distanceTo(w.mesh.position);
        if (d<bestDist){
          bestDist=d;
          best=w.mesh;
        }
      });
      return best;
    }

    function inspectNearest(){
      const w = nearestWell();
      if (!w){
        log("لا يوجد بئر قريب للفحص، اقترب أكثر.");
        return;
      }
      currentWell = w;
      log("فحص البئر "+w.userData.id+" وفتح ADJ BEAN (عرض البين).");
      updateUIForWell(w);
    }

    function cleanCurrent(){
      if (!currentWell) return;
      if (!currentWell.userData.blockage || currentWell.userData.cleaned) return;
      currentWell.userData.cleaned = true;
      log("تم تنظيف الـ blockage من ADJ BEAN للبئر "+currentWell.userData.id+" – البين أصبح نظيف.");
      updateUIForWell(currentWell);
      const choke = currentWell.getObjectByName("choke");
      if (choke) choke.material.color.set(0x22c55e);
    }

    btnOpen.addEventListener("click",()=>{
      if (!currentWell){inspectNearest();return;}
      const p = calcPressures(currentWell);
      whpEl.textContent=p.whp+" psi";
      flpEl.textContent=p.flp+" psi";
      stateEl.textContent=p.text;
      if (p.bad){
        stateTag.textContent="Blockage";
        stateTag.className="tag tag-bad";
        btnClean.classList.remove("disabled");
        log("قراءة WHP/FLP للبئر "+currentWell.userData.id+" تشير إلى Blockage – شاهد البين على اليمين.");
      } else {
        stateTag.textContent="Normal";
        stateTag.className="tag tag-ok";
        btnClean.classList.add("disabled");
        log("قراءة WHP/FLP للبئر "+currentWell.userData.id+" طبيعية – البين نظيف.");
      }
      updateBeanVisual(currentWell);
    });
    btnClean.addEventListener("click",cleanCurrent);

    document.getElementById("tc-inspect")
      .addEventListener("touchstart",e=>{e.preventDefault();inspectNearest();});
    document.getElementById("tc-clean")
      .addEventListener("touchstart",e=>{e.preventDefault();cleanCurrent();});

    log("تحرك في العالم 3D بأسلوب Roblox، اقترب من الآبار، افحص الـ ADJ BEAN ونظّف الـ blockage.");

    // Loop
    let last = performance.now();
    function animate(now){
      const delta = (now-last)/1000;
      last = now;
      updatePlayer(delta);
      renderer.render(scene,camera);
      requestAnimationFrame(animate);
    }
    onResize();
    requestAnimationFrame(animate);
  </script>
</body>
</html>
