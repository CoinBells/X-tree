<!DOCTYPE html>
<html lang="ar">
<head>
  <meta charset="UTF-8" />
  <title>ğŸ›¢ï¸ KOC X-Tree Training â€” Realistic 3D</title>
  <style>
    * { box-sizing: border-box; direction: rtl; }
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #11141f;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #fff;
    }
    canvas {
      position: fixed;
      inset: 0;
      display: block;
      z-index: 0;
    }
    #hud {
      position: fixed;
      top: 10px;
      right: 10px;
      width: 330px;
      max-width: 85vw;
      background: rgba(5, 7, 15, 0.9);
      border-radius: 12px;
      padding: 10px 13px;
      font-size: 13px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      backdrop-filter: blur(7px);
      z-index: 10;
    }
    #hud h1 { font-size: 15px; margin: 0 0 3px 0; }
    #hud p  { margin: 3px 0; }
    #hud small { opacity: 0.75; }
    #objectiveText {
      margin-top: 4px;
      font-weight: 600;
      color: #ffd27f;
    }
    #steps {
      list-style: none;
      padding: 0;
      margin: 4px 0 2px 0;
    }
    #steps li { margin: 1px 0; font-size: 12px; }
    .pending::before { content: "â—‹ "; color: #999; }
    .active::before  { content: "â— "; color: #ffd27f; }
    .done::before    { content: "âœ” "; color: #4caf50; }

    #gaugesPanel {
      margin-top: 5px;
      padding: 6px 8px;
      border-radius: 8px;
      background: radial-gradient(circle at top, #2a324a, #121420);
      border: 1px solid rgba(255, 255, 255, 0.12);
      cursor: pointer;
    }
    #gaugesPanel h3 { margin: 0 0 3px 0; font-size: 13px; }
    #gaugesPanel p  { margin: 1px 0; font-size: 12px; }

    #statusBar {
      margin-top: 5px;
      font-size: 12px;
      color: #9effc0;
      min-height: 16px;
    }
    #hint {
      margin-top: 3px;
      font-size: 11px;
      color: #b6b6b6;
    }

    #completeOverlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.78);
      z-index: 20;
    }
    #completeOverlay .box {
      padding: 18px 22px;
      background: #0c101f;
      border-radius: 16px;
      text-align: center;
      border: 1px solid #4caf50;
      box-shadow: 0 0 28px rgba(0,0,0,0.7);
      max-width: 90vw;
    }
    #completeOverlay h2 { margin: 0 0 6px 0; font-size: 18px; }
    #completeOverlay p  { margin: 4px 0; font-size: 13px; }
    #completeOverlay button {
      margin-top: 10px;
      padding: 6px 15px;
      border-radius: 999px;
      border: none;
      background: #4caf50;
      color: #fff;
      cursor: pointer;
      font-weight: 600;
      font-size: 13px;
    }
    #completeOverlay button:hover { background: #3f9144; }

    #debugMsg {
      position: fixed;
      bottom: 8px;
      left: 8px;
      padding: 6px 10px;
      background: rgba(160, 30, 30, 0.95);
      color: #fff;
      font-size: 11px;
      border-radius: 6px;
      z-index: 30;
      display: none;
    }

    @media (max-width: 600px) {
      #hud { left: 10px; width: auto; }
      #hud h1 { font-size: 14px; }
    }
  </style>
</head>
<body>
  <div id="hud">
    <h1>ğŸ›¢ï¸ KOC X-Tree Training â€” 3D ÙˆØ§Ù‚Ø¹ÙŠ</h1>
    <p><small>Ù…Ø­Ø§ÙƒØ§Ø© ÙˆØ§Ù‚Ø¹ÙŠØ© Ù„Ø´Ø¬Ø±Ø© Ø§Ù„Ø¨Ø¦Ø± ÙˆØ§Ù„Ù€ Hook-Up Ù„ØªØ¯Ø±ÙŠØ¨ Ø§Ù„ÙÙŠÙ„Ø¯ Ø£ÙˆØ¨Ø±ÙŠØªØ± Ø¹Ù„Ù‰ WHP / FLP / Choke / Drain Sample.</small></p>
    <p id="objectiveText"></p>
    <ul id="steps">
      <li id="step1" class="active">1- Ù‚Ø±Ø§Ø¡Ø© WHP &amp; FLP Ù…Ù† Ø´Ø§Ø´Ø© Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª</li>
      <li id="step2" class="pending">2- Ø¥ØºÙ„Ø§Ù‚ ØµÙ…Ø§Ù… Upstream Ù‚Ø¨Ù„ Ø§Ù„Ø´ØºÙ„</li>
      <li id="step3" class="pending">3- ÙÙƒ/ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù€ Choke (ADJ BEAN)</li>
      <li id="step4" class="pending">4- Ø£Ø®Ø° Drain Sample Ù…Ù† Ø®Ø· Ø§Ù„Ù€ Hook-Up</li>
    </ul>

    <div id="gaugesPanel">
      <h3>ğŸ“Ÿ Ø´Ø§Ø´Ø© Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª (Ø§Ø¶ØºØ· Ù„Ù„Ù‚Ø±Ø§Ø¡Ø©)</h3>
      <p id="gaugeValues">WHP: --- psi | FLP: --- psi | CASING: --- psi</p>
      <p id="gaugeStatus">Ø§Ù„Ø­Ø§Ù„Ø©: â€”</p>
    </div>

    <div id="statusBar"></div>
    <div id="hint">
      Ø§Ø³Ø­Ø¨ Ø¨Ø¥ØµØ¨Ø¹Ùƒ Ù„ØªØ¯ÙˆÙŠØ± Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ØŒ Ù‚Ø±Ù‘Ø¨/Ø£Ø¨Ø¹Ø¯ Ø¨Ø¥ØµØ¨Ø¹ÙŠÙ† (Zoom)ØŒ ÙˆØ§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„ØµÙ…Ø§Ù…Ø§Øª ÙˆØ§Ù„Ù€ Choke ÙˆØµÙ…Ø§Ù… Ø§Ù„Ø¹ÙŠÙ†Ø© Ù„Ù„ØªÙØ§Ø¹Ù„.
    </div>
  </div>

  <div id="completeOverlay">
    <div class="box">
      <h2>âœ… Ø§Ù„ØªØ¯Ø±ÙŠØ¨ Ø§ÙƒØªÙ…Ù„ Ø¨Ù†Ø¬Ø§Ø­</h2>
      <p>Ù†ÙØ°Øª ÙƒÙ„ Ø®Ø·ÙˆØ§Øª Ø§Ù„ÙÙŠÙ„Ø¯ Ø£ÙˆØ¨Ø±ÙŠØªØ± Ø¹Ù„Ù‰ Ø§Ù„Ù€ X-Tree ÙˆØ§Ù„Ù€ Hook-Up: ØªØ´Ø®ÙŠØµ Ø§Ù†Ø³Ø¯Ø§Ø¯ Ø§Ù„Ù€ Choke ÙˆØ£Ø®Ø° Drain Sample Ø¨Ø£Ù…Ø§Ù†.</p>
      <button onclick="restartTraining()">Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ¬Ø±Ø¨Ø©</button>
    </div>
  </div>

  <div id="debugMsg"></div>

  <!-- Three.js Ù…Ù† jsDelivr -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    let scene, camera, renderer, controls;
    let raycaster, pointer;
    const interactiveObjects = [];

    let gameStep = 0;
    let whp = 360;
    let flp = 35;
    let casingPressure = 0;
    let blockageCleared = false;
    let upstreamClosed = false;
    let sampleTaken = false;

    const objectiveText = document.getElementById("objectiveText");
    const gaugeValues   = document.getElementById("gaugeValues");
    const gaugeStatus   = document.getElementById("gaugeStatus");
    const statusBar     = document.getElementById("statusBar");
    const completeOverlay = document.getElementById("completeOverlay");
    const debugMsg      = document.getElementById("debugMsg");

    const stepEls = {
      1: document.getElementById("step1"),
      2: document.getElementById("step2"),
      3: document.getElementById("step3"),
      4: document.getElementById("step4")
    };

    function setStepState(step, state) {
      stepEls[step].className = state;
    }

    function updateObjective() {
      switch (gameStep) {
        case 0:
          objectiveText.textContent =
            "Ø§Ø¨Ø¯Ø£ Ø¨Ù‚Ø±Ø§Ø¡Ø© WHP Ùˆ FLP Ù…Ù† Ø´Ø§Ø´Ø© Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª Ù„ØªØ´Ø®ÙŠØµ ÙˆØ¬ÙˆØ¯ Blockage Ø¹Ù„Ù‰ Ø§Ù„Ù€ Choke.";
          setStepState(1, "active");
          setStepState(2, "pending");
          setStepState(3, "pending");
          setStepState(4, "pending");
          break;
        case 1:
          objectiveText.textContent =
            "Ø£ØºÙ„Ù‚ ØµÙ…Ø§Ù… Upstream (wing valve Ø¹Ù„Ù‰ Ø§Ù„Ø¬Ù†Ø§Ø­ Ø§Ù„Ø£Ø²Ø±Ù‚) Ù‚Ø¨Ù„ Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ù€ Choke.";
          setStepState(1, "done");
          setStepState(2, "active");
          break;
        case 2:
          objectiveText.textContent =
            "Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ ØµÙ†Ø¯ÙˆÙ‚ Ø§Ù„Ù€ ADJ BEAN Choke Ù„ÙÙƒÙ‡ ÙˆØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø§Ù†Ø³Ø¯Ø§Ø¯ØŒ Ø«Ù… Ø±Ø§Ù‚Ø¨ ØªØºÙŠØ± WHP/FLP.";
          setStepState(2, "done");
          setStepState(3, "active");
          break;
        case 3:
          objectiveText.textContent =
            "Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ ØµÙ…Ø§Ù… Drain Sample ÙÙŠ Ø®Ø· Ø§Ù„Ù€ Hook-Up Ù„Ø£Ø®Ø° Ø¹ÙŠÙ†Ø© Ù…Ù† Ø§Ù„ØªØ¯ÙÙ‚.";
          setStepState(3, "done");
          setStepState(4, "active");
          break;
        case 4:
          objectiveText.textContent =
            "Ø§Ù„ØªØ¯Ø±ÙŠØ¨ Ù…ÙƒØªÙ…Ù„ØŒ ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ¬Ø±Ø¨Ø© Ø£Ùˆ Ø§Ø³ØªÙƒØ´Ø§Ù Ø§Ù„Ù€ X-Tree ÙÙŠ ÙˆØ¶Ø¹ Ø­Ø±.";
          setStepState(4, "done");
          break;
      }
    }

    function updateGaugesText() {
      gaugeValues.textContent =
        "WHP: " + whp.toFixed(0) +
        " psi | FLP: " + flp.toFixed(0) +
        " psi | CASING: " + casingPressure.toFixed(0) + " psi";

      if (!blockageCleared) {
        gaugeStatus.textContent =
          "Ø§Ù„Ø­Ø§Ù„Ø©: Ø§Ø­ØªÙ…Ø§Ù„ Blockage Ø¹Ù„Ù‰ Ø§Ù„Ù€ Choke (ÙØ±Ù‚ ÙƒØ¨ÙŠØ± Ø¨ÙŠÙ† WHP Ùˆ FLP).";
      } else {
        gaugeStatus.textContent =
          "Ø§Ù„Ø­Ø§Ù„Ø©: Ø§Ù„ØªØ¯ÙÙ‚ Ø·Ø¨ÙŠØ¹ÙŠ Ø¨Ø¹Ø¯ ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù€ Choke (FLP Ù‚Ø±ÙŠØ¨ Ù…Ù† WHP).";
      }
    }

    function setStatus(msg, color) {
      statusBar.textContent = msg || "";
      statusBar.style.color = color || "#9effc0";
    }

    function completeTraining() {
      gameStep = 4;
      updateObjective();
      completeOverlay.style.display = "flex";
      setStatus("Ø§ÙƒØªÙ…Ù„ Ø§Ù„ØªØ¯Ø±ÙŠØ¨. ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ¬Ø±Ø¨Ø©.", "#9effc0");
    }

    function restartTraining() {
      completeOverlay.style.display = "none";
      gameStep = 0;
      whp = 360;
      flp = 35;
      casingPressure = 0;
      blockageCleared = false;
      upstreamClosed = false;
      sampleTaken = false;

      interactiveObjects.forEach(obj => {
        if (obj.userData.type === "upstream") obj.material.color.set(0x00b894);
        if (obj.userData.type === "choke")    obj.material.color.set(0xffc107);
        if (obj.userData.type === "drain")    obj.material.color.set(0x87cefa);
      });

      updateObjective();
      updateGaugesText();
      setStatus("ØªÙ…Øª Ø¥Ø¹Ø§Ø¯Ø© Ø¶Ø¨Ø· Ø§Ù„ØªØ¯Ø±ÙŠØ¨.", "#9effc0");
    }

    document.getElementById("gaugesPanel").addEventListener("click", () => {
      if (gameStep === 0) {
        setStatus("Ù‚Ø±Ø§Ø¡Ø© WHP Ùˆ FLP Ù…Ù† Ø´Ø§Ø´Ø© Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª...", "#ffd27f");
        updateGaugesText();
        gameStep = 1;
        updateObjective();
      } else {
        updateGaugesText();
        setStatus("ØªÙ… ØªØ­Ø¯ÙŠØ« Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª.", "#9effc0");
      }
    });

    function initScene() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xb9e4ff);

      camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        200
      );
      camera.position.set(12, 9, 16);

      renderer = new THREE.WebGLRenderer({ antialias: false });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio * 0.8, 1.6));
      document.body.appendChild(renderer.domElement);
      renderer.domElement.style.position = "fixed";
      renderer.domElement.style.inset = "0";
      renderer.domElement.style.zIndex = "0";

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 3.2, 0);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.minDistance = 7;
      controls.maxDistance = 35;
      controls.maxPolarAngle = Math.PI / 2.1;
      controls.update();

      const hemiLight = new THREE.HemisphereLight(0xffffee, 0xb89b6a, 0.7);
      hemiLight.position.set(0, 40, 0);
      scene.add(hemiLight);

      const sun = new THREE.DirectionalLight(0xffffff, 1.0);
      sun.position.set(25, 35, 10);
      scene.add(sun);

      const groundGeo = new THREE.PlaneGeometry(120, 120, 32, 32);
      const groundMat = new THREE.MeshStandardMaterial({
        color: 0xd8be8e,
        roughness: 0.95,
        metalness: 0.0
      });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = 0;
      scene.add(ground);

      for (let i = 0; i < 18; i++) {
        const hillGeo = new THREE.ConeGeometry(
          0.8 + Math.random() * 1.8,
          0.7 + Math.random() * 1.3,
          6
        );
        const hillMat = new THREE.MeshStandardMaterial({
          color: 0xcfa471,
          roughness: 1.0
        });
        const hill = new THREE.Mesh(hillGeo, hillMat);
        hill.position.set(
          (Math.random() - 0.5) * 80,
          0.45,
          (Math.random() - 0.5) * 80
        );
        hill.rotation.y = Math.random() * Math.PI;
        scene.add(hill);
      }

      const padGeo = new THREE.BoxGeometry(10, 0.4, 10);
      const padMat = new THREE.MeshStandardMaterial({
        color: 0x9c9c9c,
        roughness: 0.8,
        metalness: 0.1
      });
      const pad = new THREE.Mesh(padGeo, padMat);
      pad.position.set(0, 0.2, 0);
      scene.add(pad);

      const baseGeo = new THREE.CylinderGeometry(1.2, 1.4, 0.6, 14);
      const baseMat = new THREE.MeshStandardMaterial({
        color: 0x5b6067,
        metalness: 0.5,
        roughness: 0.4
      });
      const base = new THREE.Mesh(baseGeo, baseMat);
      base.position.set(0, 0.7, 0);
      scene.add(base);

      const vertGeo = new THREE.CylinderGeometry(0.3, 0.3, 4.5, 14);
      const vertMat = new THREE.MeshStandardMaterial({
        color: 0xb3b3b3,
        metalness: 0.5,
        roughness: 0.3
      });
      const vertPipe = new THREE.Mesh(vertGeo, vertMat);
      vertPipe.position.set(0, 3.0, 0);
      scene.add(vertPipe);

      const rustMat = new THREE.MeshStandardMaterial({
        color: 0x8a4c2c,
        metalness: 0.3,
        roughness: 0.8
      });

      function createRustValve(y, sideOffset) {
        const group = new THREE.Group();

        const valveBodyGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.4, 14);
        const valveBody = new THREE.Mesh(valveBodyGeo, rustMat);
        valveBody.position.set(sideOffset, y, 0);
        valveBody.rotation.z = Math.PI / 2;
        group.add(valveBody);

        const wheelGeo = new THREE.TorusGeometry(0.7, 0.08, 10, 22);
        const wheel = new THREE.Mesh(wheelGeo, rustMat);
        wheel.position.set(sideOffset, y, 0);
        wheel.rotation.x = Math.PI / 2;
        group.add(wheel);

        const stemGeo = new THREE.CylinderGeometry(0.12, 0.12, 0.6, 10);
        const stem = new THREE.Mesh(stemGeo, rustMat);
        stem.position.set(sideOffset, y + 0.5, 0);
        group.add(stem);

        scene.add(group);
      }

      createRustValve(4.0, 0);
      createRustValve(3.0, 0);
      createRustValve(2.0, 0);

      const armGeo = new THREE.CylinderGeometry(0.22, 0.22, 3.2, 14);
      const armMat = new THREE.MeshStandardMaterial({
        color: 0xb3b3b3,
        metalness: 0.5,
        roughness: 0.35
      });

      const leftArm = new THREE.Mesh(armGeo, armMat);
      leftArm.rotation.z = Math.PI / 2;
      leftArm.position.set(-1.7, 3.0, 0);
      scene.add(leftArm);

      const rightArm = new THREE.Mesh(armGeo, armMat);
      rightArm.rotation.z = Math.PI / 2;
      rightArm.position.set(1.7, 3.0, 0);
      scene.add(rightArm);

      createRustValve(3.0, -3.0);

      const upValveBodyGeo = new THREE.CylinderGeometry(0.45, 0.45, 0.5, 16);
      const upValveMat = new THREE.MeshStandardMaterial({
        color: 0x00b894,
        metalness: 0.6,
        roughness: 0.35
      });
      const upstreamValve = new THREE.Mesh(upValveBodyGeo, upValveMat);
      upstreamValve.position.set(3.0, 3.0, 0);
      upstreamValve.rotation.z = Math.PI / 2;
      upstreamValve.userData.type = "upstream";
      interactiveObjects.push(upstreamValve);
      scene.add(upstreamValve);

      const upWheelGeo = new THREE.TorusGeometry(0.75, 0.09, 10, 24);
      const upWheelMat = new THREE.MeshStandardMaterial({
        color: 0xeeeeee,
        metalness: 0.6,
        roughness: 0.25
      });
      const upWheel = new THREE.Mesh(upWheelGeo, upWheelMat);
      upWheel.position.set(3.0, 3.0, 0);
      upWheel.rotation.x = Math.PI / 2;
      upWheel.userData.type = "upstream";
      interactiveObjects.push(upWheel);
      scene.add(upWheel);

      const lineSteelMat = new THREE.MeshStandardMaterial({
        color: 0xd0d8e0,
        metalness: 0.7,
        roughness: 0.25
      });

      const line1Geo = new THREE.CylinderGeometry(0.18, 0.18, 3.2, 14);
      const line1 = new THREE.Mesh(line1Geo, lineSteelMat);
      line1.rotation.z = Math.PI / 2;
      line1.position.set(4.4, 3.0, 0);
      scene.add(line1);

      const chokeBlockGeo = new THREE.BoxGeometry(1.5, 0.9, 0.9);
      const chokeBlockMat = new THREE.MeshStandardMaterial({
        color: 0x124d92,
        metalness: 0.6,
        roughness: 0.35
      });
      const chokeBlock = new THREE.Mesh(chokeBlockGeo, chokeBlockMat);
      chokeBlock.position.set(6.0, 3.0, 0);
      chokeBlock.userData.type = "choke";
      interactiveObjects.push(chokeBlock);
      scene.add(chokeBlock);

      const chokeWheel = new THREE.Mesh(
        new THREE.TorusGeometry(0.6, 0.08, 10, 22),
        new THREE.MeshStandardMaterial({
          color: 0xf5f5f5,
          metalness: 0.7,
          roughness: 0.25
        })
      );
      chokeWheel.position.set(6.0, 3.4, 0.45);
      chokeWheel.rotation.y = Math.PI / 2;
      chokeWheel.userData.type = "choke";
      interactiveObjects.push(chokeWheel);
      scene.add(chokeWheel);

      const downGeo = new THREE.CylinderGeometry(0.16, 0.16, 2.6, 12);
      const downPipe = new THREE.Mesh(downGeo, lineSteelMat);
      downPipe.position.set(7.2, 2.0, 0);
      scene.add(downPipe);

      const elbowGeo = new THREE.TorusGeometry(0.16, 0.08, 8, 16, Math.PI / 2);
      const elbow = new THREE.Mesh(elbowGeo, lineSteelMat);
      elbow.position.set(7.2, 0.7, 0);
      elbow.rotation.z = Math.PI / 2;
      scene.add(elbow);

      const hookLineGeo = new THREE.CylinderGeometry(0.16, 0.16, 4.5, 12);
      const hookLine = new THREE.Mesh(hookLineGeo, lineSteelMat);
      hookLine.rotation.z = Math.PI / 2;
      hookLine.position.set(9.4, 0.7, -1.0);
      scene.add(hookLine);

      const drainValveGeo = new THREE.SphereGeometry(0.28, 18, 18);
      const drainValveMat = new THREE.MeshStandardMaterial({
        color: 0x87cefa,
        metalness: 0.5,
        roughness: 0.3
      });
      const drainValve = new THREE.Mesh(drainValveGeo, drainValveMat);
      drainValve.position.set(11.0, 0.7, -1.0);
      drainValve.userData.type = "drain";
      interactiveObjects.push(drainValve);
      scene.add(drainValve);

      const gaugePanelGeo = new THREE.BoxGeometry(2.0, 1.2, 0.16);
      const gaugePanelMat = new THREE.MeshStandardMaterial({
        color: 0x111a26,
        emissive: 0x0b1628,
        roughness: 0.6
      });
      const gaugePanel3D = new THREE.Mesh(gaugePanelGeo, gaugePanelMat);
      gaugePanel3D.position.set(-6.0, 3.0, 3.5);
      gaugePanel3D.userData.type = "gauges3d";
      interactiveObjects.push(gaugePanel3D);
      scene.add(gaugePanel3D);

      const legGeo = new THREE.CylinderGeometry(0.09, 0.09, 2.0, 10);
      const legMat = new THREE.MeshStandardMaterial({
        color: 0x444444,
        roughness: 0.7
      });
      const leg1 = new THREE.Mesh(legGeo, legMat);
      leg1.position.set(-6.4, 2.0, 3.5);
      scene.add(leg1);
      const leg2 = leg1.clone();
      leg2.position.set(-5.6, 2.0, 3.5);
      scene.add(leg2);

      raycaster = new THREE.Raycaster();
      pointer = new THREE.Vector2();

      window.addEventListener("pointerdown", onPointerDown, false);
      window.addEventListener("resize", onWindowResize, false);

      updateObjective();
      updateGaugesText();
      setStatus("Ø§Ø¨Ø¯Ø£ Ø¨Ù‚Ø±Ø§Ø¡Ø© WHP Ùˆ FLP Ù…Ù† Ø´Ø§Ø´Ø© Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª (HUD Ø£Ùˆ Ù„ÙˆØ­Ø© 3D).", "#ffd27f");
    }

    function onPointerDown(event) {
      if (!renderer) return;
      const rect = renderer.domElement.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;

      pointer.x = (x / rect.width) * 2 - 1;
      pointer.y = -(y / rect.height) * 2 + 1;

      raycaster.setFromCamera(pointer, camera);
      const intersects = raycaster.intersectObjects(interactiveObjects, true);
      if (intersects.length === 0) return;

      let obj = intersects[0].object;
      while (obj && !obj.userData.type && obj.parent) obj = obj.parent;
      if (!obj || !obj.userData.type) return;

      handleGameClick(obj.userData.type, obj);
    }

    function handleGameClick(type, obj) {
      if (type === "gauges3d") {
        if (gameStep === 0) {
          setStatus("Ù‚Ø±Ø§Ø¡Ø© WHP Ùˆ FLP Ù…Ù† Ù„ÙˆØ­Ø© Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª 3D...", "#ffd27f");
          updateGaugesText();
          gameStep = 1;
          updateObjective();
        } else {
          updateGaugesText();
          setStatus("ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù‚Ø±Ø§Ø¡Ø© Ù…Ù† Ù„ÙˆØ­Ø© Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª.", "#9effc0");
        }
        return;
      }

      if (type === "upstream") {
        if (gameStep < 1) {
          setStatus("Ø£Ù‚Ø±Ø£ Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª Ø£ÙˆÙ„Ø§Ù‹ Ù‚Ø¨Ù„ Ø¥ØºÙ„Ø§Ù‚ ØµÙ…Ø§Ù… Upstream.", "#ff8080");
          return;
        }
        if (!upstreamClosed) {
          upstreamClosed = true;
          obj.material.color.set(0xe53935);
          setStatus("ØªÙ… Ø¥ØºÙ„Ø§Ù‚ ØµÙ…Ø§Ù… Upstream Ø¨Ù†Ø¬Ø§Ø­.", "#9effc0");
          if (gameStep === 1) {
            gameStep = 2;
            updateObjective();
          }
        } else {
          setStatus("ØµÙ…Ø§Ù… Upstream Ù…ØºÙ„Ù‚ Ø¨Ø§Ù„ÙØ¹Ù„.", "#cccccc");
        }
        return;
      }

      if (type === "choke") {
        if (gameStep < 2) {
          setStatus("Ø£ØºÙ„Ù‚ ØµÙ…Ø§Ù… Upstream Ù‚Ø¨Ù„ Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ù€ Choke.", "#ff8080");
          return;
        }
        if (!blockageCleared) {
          blockageCleared = true;
          whp = 300;
          flp = 280;
          casingPressure = 55;
          obj.material.color.set(0x43a047);
          updateGaugesText();
          setStatus("ØªÙ… ÙÙƒ ÙˆØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù€ Choke. FLP Ø§Ù„Ø¢Ù† Ù‚Ø±ÙŠØ¨ Ù…Ù† WHP.", "#9effc0");
          if (gameStep === 2) {
            gameStep = 3;
            updateObjective();
          }
        } else {
          setStatus("Ø§Ù„Ù€ Choke Ù†Ø¸ÙŠÙ Ø­Ø§Ù„ÙŠØ§Ù‹ØŒ Ù„Ø§ ÙŠÙˆØ¬Ø¯ Blockage.", "#cccccc");
        }
        return;
      }

      if (type === "drain") {
        if (gameStep < 3) {
          setStatus("Ù†Ø¸Ù Ø§Ù„Ù€ Choke Ø«Ù… Ø®Ø° Drain Sample.", "#ff8080");
          return;
        }
        if (!sampleTaken) {
          sampleTaken = true;
          obj.material.color.set(0x00bcd4);

          const bottleGeo = new THREE.CylinderGeometry(0.18, 0.18, 0.7, 12);
          const bottleMat = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            metalness: 0.1,
            roughness: 0.2,
            transparent: true,
            opacity: 0.85
          });
          const bottle = new THREE.Mesh(bottleGeo, bottleMat);
          bottle.position.copy(obj.position);
          bottle.position.y -= 0.6;
          scene.add(bottle);

          setStatus("ØªÙ… Ø£Ø®Ø° Drain Sample Ù…Ù† Ø®Ø· Ø§Ù„Ù€ Hook-Up Ø¨Ù†Ø¬Ø§Ø­.", "#9effc0");
          if (gameStep === 3) completeTraining();
        } else {
          setStatus("Ø§Ù„Ø¹ÙŠÙ†Ø© Ù…Ø£Ø®ÙˆØ°Ø© Ø¨Ø§Ù„ÙØ¹Ù„ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ø¯ÙˆØ±Ø©.", "#cccccc");
        }
        return;
      }
    }

    function onWindowResize() {
      if (!camera || !renderer) return;
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      if (controls && renderer && scene && camera) {
        controls.update();
        renderer.render(scene, camera);
      }
    }

    // ØªØ´ØºÙŠÙ„ Ø¨Ø¹Ø¯ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙØ­Ø© + Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ØªÙˆÙØ± THREE
    window.addEventListener("load", function () {
      if (typeof THREE === "undefined") {
        debugMsg.style.display = "block";
        debugMsg.textContent = "Three.js Ù„Ù… ÙŠØªÙ… ØªØ­Ù…ÙŠÙ„Ù‡ (ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù„Ø§ØªØµØ§Ù„ Ø£Ùˆ Ù…Ù† Ø§Ù„Ù€ CDN).";
        return;
      }
      try {
        initScene();
        animate();
      } catch (e) {
        debugMsg.style.display = "block";
        debugMsg.textContent = "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©: " + e.message;
      }
    });
  </script>
</body>
</html>
