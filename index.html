<!DOCTYPE html>
<html lang="ar">
<head>
  <meta charset="UTF-8" />
  <title>ğŸ›¢ï¸ KOC X-Tree Training â€” 3D</title>
  <style>
    * { box-sizing: border-box; direction: rtl; }
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #11141f;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #fff;
    }
    canvas {
      position: fixed;
      inset: 0;
      display: block;
      z-index: 0;
    }
    #hud {
      position: fixed;
      top: 10px;
      right: 10px;
      width: 330px;
      max-width: 85vw;
      background: rgba(5, 7, 15, 0.9);
      border-radius: 12px;
      padding: 10px 13px;
      font-size: 13px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      backdrop-filter: blur(7px);
      z-index: 10;
    }
    #hud h1 { font-size: 15px; margin: 0 0 3px 0; }
    #hud p  { margin: 3px 0; }
    #hud small { opacity: 0.75; }
    #objectiveText { margin-top: 4px; font-weight: 600; color: #ffd27f; }
    #steps { list-style: none; padding: 0; margin: 4px 0 2px 0; }
    #steps li { margin: 1px 0; font-size: 12px; }
    .pending::before { content: "â—‹ "; color: #999; }
    .active::before  { content: "â— "; color: #ffd27f; }
    .done::before    { content: "âœ” "; color: #4caf50; }

    #gaugesPanel {
      margin-top: 5px;
      padding: 6px 8px;
      border-radius: 8px;
      background: radial-gradient(circle at top, #2a324a, #121420);
      border: 1px solid rgba(255, 255, 255, 0.12);
      cursor: pointer;
    }
    #gaugesPanel h3 { margin: 0 0 3px 0; font-size: 13px; }
    #gaugesPanel p  { margin: 1px 0; font-size: 12px; }

    #statusBar {
      margin-top: 5px;
      font-size: 12px;
      color: #9effc0;
      min-height: 16px;
    }
    #hint {
      margin-top: 3px;
      font-size: 11px;
      color: #b6b6b6;
    }

    #completeOverlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.78);
      z-index: 20;
    }
    #completeOverlay .box {
      padding: 18px 22px;
      background: #0c101f;
      border-radius: 16px;
      text-align: center;
      border: 1px solid #4caf50;
      box-shadow: 0 0 28px rgba(0,0,0,0.7);
      max-width: 90vw;
    }
    #completeOverlay h2 { margin: 0 0 6px 0; font-size: 18px; }
    #completeOverlay p  { margin: 4px 0; font-size: 13px; }
    #completeOverlay button {
      margin-top: 10px;
      padding: 6px 15px;
      border-radius: 999px;
      border: none;
      background: #4caf50;
      color: #fff;
      cursor: pointer;
      font-weight: 600;
      font-size: 13px;
    }

    #debugMsg {
      position: fixed;
      bottom: 8px;
      left: 8px;
      padding: 6px 10px;
      background: rgba(160, 30, 30, 0.95);
      color: #fff;
      font-size: 11px;
      border-radius: 6px;
      z-index: 30;
      display: none;
    }

    /* Ø£Ø²Ø±Ø§Ø± ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø¹Ø§Ù…Ù„ */
    #moveControls {
      position: fixed;
      bottom: 14px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 15;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      user-select: none;
    }
    #moveControls-row {
      display: flex;
      gap: 6px;
    }
    .mvBtn {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      border: none;
      background: rgba(15, 20, 40, 0.95);
      color: #fff;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
    }
    .mvBtn:active { background: rgba(40, 80, 160, 0.95); }

    @media (max-width: 600px) {
      #hud { left: 10px; width: auto; }
      #hud h1 { font-size: 14px; }
    }
  </style>
</head>
<body>
  <div id="hud">
    <h1>ğŸ›¢ï¸ KOC X-Tree Training â€” 3D</h1>
    <p><small>
      X-Tree + Hook-Up + Manifold (6") Ù„ØªØ¯Ø±ÙŠØ¨ Ø§Ù„ÙÙŠÙ„Ø¯ Ø£ÙˆØ¨Ø±ÙŠØªØ± Ø¹Ù„Ù‰ Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ù€ Choke ÙˆØ§Ù„Ù€ Blockage ÙˆØ§Ù„Ù€ Drain Sample.
    </small></p>
    <p id="objectiveText"></p>
    <ul id="steps">
      <li id="step1" class="active">1- Ù‚Ø±Ø§Ø¡Ø© WHP &amp; FLP Ù…Ù† Ø´Ø§Ø´Ø© Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª</li>
      <li id="step2" class="pending">2- ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø¹Ø§Ù…Ù„ Ù„Ù„Ø¨Ø¦Ø± ÙˆØ¥ØºÙ„Ø§Ù‚ ØµÙ…Ø§Ù… Upstream</li>
      <li id="step3" class="pending">3- ÙØªØ­ Ø§Ù„Ù€ ADJ BEAN Ù„Ø±Ø¤ÙŠØ© Ø§Ù„Ø³Ø¨ÙˆÙ„ ÙˆØ§Ù„Ù€ Blockage</li>
      <li id="step4" class="pending">4- ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø³Ø¨ÙˆÙ„ ÙˆØ£Ø®Ø° Drain Sample Ù…Ù† Ø§Ù„Ø®Ø· 6"</li>
    </ul>

    <div id="gaugesPanel">
      <h3>ğŸ“Ÿ Ø´Ø§Ø´Ø© Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª (Ø§Ø¶ØºØ· Ù„Ù„Ù‚Ø±Ø§Ø¡Ø©)</h3>
      <p id="gaugeValues">WHP: --- psi | FLP: --- psi | CASING: --- psi</p>
      <p id="gaugeStatus">Ø§Ù„Ø­Ø§Ù„Ø©: â€”</p>
    </div>

    <div id="statusBar"></div>
    <div id="hint">
      Ø­Ø±Ù‘Ùƒ Ø§Ù„Ø¹Ø§Ù…Ù„ Ø¨Ø§Ù„Ø£Ø³Ù‡Ù… ÙÙŠ Ø§Ù„Ø£Ø³ÙÙ„ØŒ ÙˆÙ‚Ø±Ù‘Ø¨Ù‡ Ù…Ù† X-Tree Ø£Ùˆ Hook-Up Ø£Ùˆ Manifold Ø«Ù… Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø§Ù„ØµÙ…Ø§Ù…Ø§Øª ÙˆØ§Ù„Ù€ Choke ÙˆØ§Ù„Ù€ Drain Sample Ù„Ù„ØªÙØ§Ø¹Ù„.
    </div>
  </div>

  <div id="moveControls">
    <button class="mvBtn" onclick="moveOperator('forward')">â†‘</button>
    <div id="moveControls-row">
      <button class="mvBtn" onclick="moveOperator('left')">â†</button>
      <button class="mvBtn" onclick="moveOperator('back')">â†“</button>
      <button class="mvBtn" onclick="moveOperator('right')">â†’</button>
    </div>
  </div>

  <div id="completeOverlay">
    <div class="box">
      <h2>âœ… Ø§Ù„ØªØ¯Ø±ÙŠØ¨ Ø§ÙƒØªÙ…Ù„ Ø¨Ù†Ø¬Ø§Ø­</h2>
      <p>Ø§Ù„Ø¹Ø§Ù…Ù„ Ù†ÙÙ‘Ø° Ø¥Ø¬Ø±Ø§Ø¡Ø§Øª Ø§Ù„Ø¨Ø¦Ø±: ØªØ´Ø®ÙŠØµ Blockage Ø¹Ù„Ù‰ Ø§Ù„Ù€ Choke ÙÙŠ Ø§Ù„Ù€ Hook-UpØŒ ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø³Ø¨ÙˆÙ„ØŒ ÙˆØ£Ø®Ø° Drain Sample Ù…Ù† Ø®Ø· 6" Ø¥Ù„Ù‰ Ø§Ù„Ù€ Manifold.</p>
      <button onclick="restartTraining()">Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ¬Ø±Ø¨Ø©</button>
    </div>
  </div>

  <div id="debugMsg"></div>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    let scene, camera, renderer, controls;
    let raycaster, pointer;
    const interactiveObjects = [];

    let operator; // Ø§Ù„Ø¹Ø§Ù…Ù„
    let gameStep = 0;
    let whp = 360;
    let flp = 35;
    let casingPressure = 0;

    let blockageCleared = false;
    let upstreamClosed = false;
    let sampleTaken   = false;
    let chokeOpened   = false;

    let spoolOuter, spoolInnerDirty, spoolInnerClean;

    const objectiveText   = document.getElementById("objectiveText");
    const gaugeValues     = document.getElementById("gaugeValues");
    const gaugeStatus     = document.getElementById("gaugeStatus");
    const statusBar       = document.getElementById("statusBar");
    const completeOverlay = document.getElementById("completeOverlay");
    const debugMsg        = document.getElementById("debugMsg");

    const stepEls = {
      1: document.getElementById("step1"),
      2: document.getElementById("step2"),
      3: document.getElementById("step3"),
      4: document.getElementById("step4")
    };

    function setStepState(step, state) { stepEls[step].className = state; }

    function updateObjective() {
      switch (gameStep) {
        case 0:
          objectiveText.textContent =
            "Ø§Ø¨Ø¯Ø£ Ø¨Ù‚Ø±Ø§Ø¡Ø© WHP Ùˆ FLP Ù…Ù† Ø´Ø§Ø´Ø© Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª Ù„ØªØ´Ø®ÙŠØµ Ø§Ø­ØªÙ…Ø§Ù„ Blockage Ø¹Ù„Ù‰ Ø§Ù„Ù€ Choke.";
          setStepState(1, "active");
          setStepState(2, "pending");
          setStepState(3, "pending");
          setStepState(4, "pending");
          break;
        case 1:
          objectiveText.textContent =
            "Ø­Ø±Ù‘Ùƒ Ø§Ù„Ø¹Ø§Ù…Ù„ Ø¨Ø§Ù„Ù‚Ø±Ø¨ Ù…Ù† X-Tree Ø«Ù… Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ ØµÙ…Ø§Ù… Upstream (Primary Wing Valve Ø§Ù„Ø£Ø²Ø±Ù‚).";
          setStepState(1, "done");
          setStepState(2, "active");
          break;
        case 2:
          objectiveText.textContent =
            "ÙˆØ¬Ù‘Ù‡ Ø§Ù„Ø¹Ø§Ù…Ù„ Ù„Ù„Ù€ Hook-Up ÙˆØ§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø¨Ù„ÙˆÙƒ Ø§Ù„Ù€ ADJ BEAN (Choke) Ù„ÙØªØ­Ù‡Ø§ ÙˆØ±Ø¤ÙŠØ© Ø§Ù„Ø³Ø¨ÙˆÙ„ Ø§Ù„Ù…ØªØ³Ø®.";
          setStepState(2, "done");
          setStepState(3, "active");
          break;
        case 3:
          objectiveText.textContent =
            "Ø§Ø¶ØºØ· Ù…Ø±Ø© Ø«Ø§Ù†ÙŠØ© Ø¹Ù„Ù‰ Ø§Ù„Ù€ ADJ BEAN Ù„ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø³Ø¨ÙˆÙ„ (Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù€ Blockage) Ø«Ù… ØªÙˆØ¬Ù‘Ù‡ Ø¥Ù„Ù‰ Drain Sample Ø¹Ù„Ù‰ Ø®Ø· 6\".";
          setStepState(3, "active");
          break;
        case 4:
          objectiveText.textContent =
            "Ù‚Ø±Ù‘Ø¨ Ø§Ù„Ø¹Ø§Ù…Ù„ Ù…Ù† ØµÙ…Ø§Ù… Drain Sample Ø¹Ù„Ù‰ Ø®Ø· 6\" ÙˆØ§Ø¶ØºØ· Ø¹Ù„ÙŠÙ‡ Ù„Ø£Ø®Ø° Ø§Ù„Ø¹ÙŠÙ†Ø© ÙˆØ¥Ù†Ù‡Ø§Ø¡ Ø§Ù„ØªØ¯Ø±ÙŠØ¨.";
          setStepState(3, "done");
          setStepState(4, "active");
          break;
        case 5:
          objectiveText.textContent =
            "Ø§Ù„ØªØ¯Ø±ÙŠØ¨ Ù…ÙƒØªÙ…Ù„ØŒ ØªÙ‚Ø¯Ø± ØªØ¹ÙŠØ¯ Ø£Ùˆ ØªØ³ØªÙƒØ´Ù X-Tree ÙˆØ§Ù„Ø®Ø· Ø¥Ù„Ù‰ Ø§Ù„Ù€ Manifold Ø¨Ø­Ø±ÙŠØ©.";
          setStepState(4, "done");
          break;
      }
    }

    function updateGaugesText() {
      gaugeValues.textContent =
        "WHP: " + whp.toFixed(0) +
        " psi | FLP: " + flp.toFixed(0) +
        " psi | CASING: " + casingPressure.toFixed(0) + " psi";

      if (!blockageCleared) {
        gaugeStatus.textContent =
          "Ø§Ù„Ø­Ø§Ù„Ø©: Ø§Ø­ØªÙ…Ø§Ù„ Blockage Ø¹Ù„Ù‰ Ø§Ù„Ù€ Choke (ÙØ±Ù‚ ÙƒØ¨ÙŠØ± Ø¨ÙŠÙ† WHP Ùˆ FLP).";
      } else {
        gaugeStatus.textContent =
          "Ø§Ù„Ø­Ø§Ù„Ø©: Ø§Ù„ØªØ¯ÙÙ‚ Ø·Ø¨ÙŠØ¹ÙŠ Ø¨Ø¹Ø¯ ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø³Ø¨ÙˆÙ„ ÙˆØ§Ù„Ù€ Choke (FLP Ù‚Ø±ÙŠØ¨ Ù…Ù† WHP).";
      }
    }

    function setStatus(msg, color) {
      statusBar.textContent = msg || "";
      statusBar.style.color = color || "#9effc0";
    }

    function completeTraining() {
      gameStep = 5;
      updateObjective();
      completeOverlay.style.display = "flex";
      setStatus("Ø§ÙƒØªÙ…Ù„ Ø³ÙŠÙ†Ø§Ø±ÙŠÙˆ Ø§Ù„ØªØ¯Ø±ÙŠØ¨.", "#9effc0");
    }

    function restartTraining() {
      completeOverlay.style.display = "none";
      gameStep = 0;
      whp = 360;
      flp = 35;
      casingPressure = 0;
      blockageCleared = false;
      upstreamClosed = false;
      sampleTaken = false;
      chokeOpened = false;

      interactiveObjects.forEach(obj => {
        if (obj.userData.type === "upstream") obj.material.color.set(0x1e88e5);
        if (obj.userData.type === "chokeBlock")    obj.material.color.set(0x1565c0);
      });

      if (spoolOuter) spoolOuter.visible = false;
      if (spoolInnerDirty) spoolInnerDirty.visible = false;
      if (spoolInnerClean) spoolInnerClean.visible = false;

      if (operator) {
        operator.position.set(-5, 0, 2);
      }

      updateObjective();
      updateGaugesText();
      setStatus("ØªÙ…Øª Ø¥Ø¹Ø§Ø¯Ø© Ø¶Ø¨Ø· Ø§Ù„ØªØ¯Ø±ÙŠØ¨.", "#9effc0");
    }

    document.getElementById("gaugesPanel").addEventListener("click", () => {
      if (gameStep === 0) {
        setStatus("Ù‚Ø±Ø§Ø¡Ø© WHP Ùˆ FLP Ù…Ù† Ø´Ø§Ø´Ø© Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª...", "#ffd27f");
        updateGaugesText();
        gameStep = 1;
        updateObjective();
      } else {
        updateGaugesText();
        setStatus("ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù‚Ø±Ø§Ø¡Ø©.", "#9effc0");
      }
    });

    // ØªØ­Ø±ÙŠÙƒ Ø§Ù„Ø¹Ø§Ù…Ù„ Ù…Ù† Ø§Ù„Ø£Ø²Ø±Ø§Ø±
    function moveOperator(dir) {
      if (!operator) return;
      const step = 0.7;
      if (dir === "left")  operator.position.x -= step;
      if (dir === "right") operator.position.x += step;
      if (dir === "forward") operator.position.z -= step;
      if (dir === "back")    operator.position.z += step;
      clampOperator();
    }
    window.moveOperator = moveOperator; // Ø¹Ø´Ø§Ù† ØªØ´ØªØºÙ„ Ù…Ø¹ onClick

    function clampOperator() {
      if (!operator) return;
      operator.position.x = Math.max(-7, Math.min(18, operator.position.x));
      operator.position.z = Math.max(-4, Math.min(4, operator.position.z));
    }

    function isOperatorNear(obj, maxDist) {
      if (!operator) return true;
      const worldPos = new THREE.Vector3();
      obj.getWorldPosition(worldPos);
      const dist = operator.position.distanceTo(worldPos);
      return dist <= (maxDist || 2.5);
    }

    function initScene() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xbfd7ff);

      camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        200
      );
      camera.position.set(10, 7, 18);

      renderer = new THREE.WebGLRenderer({ antialias: false });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio * 0.8, 1.6));
      document.body.appendChild(renderer.domElement);

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.target.set(4, 3.0, 0);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.minDistance = 10;
      controls.maxDistance = 35;
      controls.maxPolarAngle = Math.PI / 2.1;
      controls.update();

      const hemiLight = new THREE.HemisphereLight(0xffffee, 0xb89b6a, 0.7);
      hemiLight.position.set(0, 40, 0);
      scene.add(hemiLight);

      const sun = new THREE.DirectionalLight(0xffffff, 1.0);
      sun.position.set(25, 35, 10);
      scene.add(sun);

      // Ø£Ø±Ø¶ÙŠØ©
      const groundGeo = new THREE.PlaneGeometry(160, 100);
      const groundMat = new THREE.MeshStandardMaterial({
        color: 0xd8c79a,
        roughness: 0.95
      });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = 0;
      scene.add(ground);

      // Ø¨Ø¹Ø¶ Ø§Ù„ØªÙ„Ø§Ù„
      for (let i = 0; i < 16; i++) {
        const hillGeo = new THREE.ConeGeometry(1.0, 0.8, 6);
        const hillMat = new THREE.MeshStandardMaterial({
          color: 0xcfa471,
          roughness: 1.0
        });
        const hill = new THREE.Mesh(hillGeo, hillMat);
        hill.position.set(
          (Math.random() - 0.2) * 70,
          0.4,
          (Math.random() - 0.5) * 40
        );
        hill.rotation.y = Math.random() * Math.PI;
        scene.add(hill);
      }

      // Ù…Ù†ØµØ© Ø§Ù„Ø¨Ø¦Ø±
      const padGeo = new THREE.BoxGeometry(10, 0.4, 10);
      const padMat = new THREE.MeshStandardMaterial({
        color: 0x9c9c9c,
        roughness: 0.8,
        metalness: 0.1
      });
      const pad = new THREE.Mesh(padGeo, padMat);
      pad.position.set(0, 0.2, 0);
      scene.add(pad);

      // X-TREE (Ø£Ù„ÙˆØ§Ù† Ø²Ø±Ù‚Ø§Ø¡ Ù…Ø«Ù„ Ø§Ù„ØµÙˆØ±Ø©)
      const bluePipeMat = new THREE.MeshStandardMaterial({
        color: 0x1e88e5,
        metalness: 0.7,
        roughness: 0.3
      });
      const blueDarkMat = new THREE.MeshStandardMaterial({
        color: 0x0d47a1,
        metalness: 0.7,
        roughness: 0.3
      });

      // Ù‚Ø§Ø¹Ø¯Ø©
      const baseGeo = new THREE.CylinderGeometry(1.2, 1.4, 0.6, 20);
      const baseMat = new THREE.MeshStandardMaterial({
        color: 0x546e7a,
        metalness: 0.5,
        roughness: 0.5
      });
      const base = new THREE.Mesh(baseGeo, baseMat);
      base.position.set(0, 0.7, 0);
      scene.add(base);

      // Ø£Ù†Ø¨ÙˆØ¨ Ø±Ø£Ø³ÙŠ
      const vertGeo = new THREE.CylinderGeometry(0.35, 0.35, 4.8, 20);
      const vertPipe = new THREE.Mesh(vertGeo, bluePipeMat);
      vertPipe.position.set(0, 3.1, 0);
      scene.add(vertPipe);

      // ØªØ¯Ø±Ø¬Ø§Øª T-Cap + Swab + Gauge ØªÙ‚Ø±ÙŠØ¨ÙŠØ©
      const swab1Geo = new THREE.CylinderGeometry(0.32, 0.32, 0.5, 16);
      const swab1 = new THREE.Mesh(swab1Geo, bluePipeMat);
      swab1.position.set(0, 4.9, 0);
      scene.add(swab1);

      const swab2Geo = new THREE.CylinderGeometry(0.26, 0.26, 0.4, 16);
      const swab2 = new THREE.Mesh(swab2Geo, bluePipeMat);
      swab2.position.set(0, 5.4, 0);
      scene.add(swab2);

      const gaugeGeo = new THREE.SphereGeometry(0.18, 12, 12);
      const gaugeMat = new THREE.MeshStandardMaterial({
        color: 0xffffff,
        metalness: 0.3,
        roughness: 0.3
      });
      const gauge = new THREE.Mesh(gaugeGeo, gaugeMat);
      gauge.position.set(0, 5.9, 0);
      scene.add(gauge);

      // handwheel function
      function createWheel(y, xOffset) {
        const group = new THREE.Group();

        const bodyGeo = new THREE.CylinderGeometry(0.45, 0.45, 0.5, 20);
        const body = new THREE.Mesh(bodyGeo, bluePipeMat);
        body.position.set(xOffset, y, 0);
        body.rotation.z = Math.PI / 2;
        group.add(body);

        const wheelGeo = new THREE.TorusGeometry(0.9, 0.09, 16, 28);
        const wheel = new THREE.Mesh(wheelGeo, blueDarkMat);
        wheel.position.set(xOffset, y, 0);
        wheel.rotation.x = Math.PI / 2;
        group.add(wheel);

        const stemGeo = new THREE.CylinderGeometry(0.12, 0.12, 0.7, 12);
        const stem = new THREE.Mesh(stemGeo, bluePipeMat);
        stem.position.set(xOffset, y + 0.55, 0);
        group.add(stem);

        scene.add(group);
      }

      // Upper / Middle / Lower Master
      createWheel(4.2, 0);
      createWheel(3.1, 0);
      createWheel(2.0, 0);

      // Ø§Ù„Ø£Ø°Ø±Ø¹ Ø§Ù„Ø¬Ø§Ù†Ø¨ÙŠØ©
      const armGeo = new THREE.CylinderGeometry(0.26, 0.26, 3.8, 20);
      const arm = new THREE.Mesh(armGeo, bluePipeMat);
      arm.rotation.z = Math.PI / 2;
      arm.position.set(0, 3.1, 0);
      scene.add(arm);

      // Kill Wing Valve ÙŠØ³Ø§Ø± (ØºÙŠØ± ØªÙØ§Ø¹Ù„ÙŠ)
      createWheel(3.1, -3.3);

      // Primary Wing Valve ÙŠÙ…ÙŠÙ† (Upstream ØªÙØ§Ø¹Ù„ÙŠ)
      const upstreamBodyGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.6, 20);
      const upstreamValve = new THREE.Mesh(upstreamBodyGeo, bluePipeMat);
      upstreamValve.position.set(3.3, 3.1, 0);
      upstreamValve.rotation.z = Math.PI / 2;
      upstreamValve.userData.type = "upstream";
      interactiveObjects.push(upstreamValve);
      scene.add(upstreamValve);

      const upstreamWheelGeo = new THREE.TorusGeometry(0.9, 0.09, 16, 28);
      const upstreamWheel = new THREE.Mesh(upstreamWheelGeo, blueDarkMat);
      upstreamWheel.position.set(3.3, 3.1, 0);
      upstreamWheel.rotation.x = Math.PI / 2;
      upstreamWheel.userData.type = "upstream";
      interactiveObjects.push(upstreamWheel);
      scene.add(upstreamWheel);

      // HOOK-UP + ADJ BEAN (Ù‚Ø±ÙŠØ¨ Ù…Ù† Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø«Ø§Ù„Ø«Ø©)
      const steelMat = new THREE.MeshStandardMaterial({
        color: 0xd0d8e0,
        metalness: 0.8,
        roughness: 0.25
      });

      const hook1Geo = new THREE.CylinderGeometry(0.22, 0.22, 3.0, 18);
      const hook1 = new THREE.Mesh(hook1Geo, steelMat);
      hook1.rotation.z = Math.PI / 2;
      hook1.position.set(4.8, 3.1, 0);
      scene.add(hook1);

      const chokeBlockGeo = new THREE.BoxGeometry(1.7, 1.0, 1.1);
      const chokeBlockMat = new THREE.MeshStandardMaterial({
        color: 0x1565c0,
        metalness: 0.8,
        roughness: 0.35
      });
      const chokeBlock = new THREE.Mesh(chokeBlockGeo, chokeBlockMat);
      chokeBlock.position.set(6.4, 3.1, 0);
      chokeBlock.userData.type = "chokeBlock";
      interactiveObjects.push(chokeBlock);
      scene.add(chokeBlock);

      const chokeWheel = new THREE.Mesh(
        new THREE.TorusGeometry(0.7, 0.08, 12, 24),
        new THREE.MeshStandardMaterial({
          color: 0xf5f5f5,
          metalness: 0.7,
          roughness: 0.25
        })
      );
      chokeWheel.position.set(6.4, 3.6, 0.55);
      chokeWheel.rotation.y = Math.PI / 2;
      chokeWheel.userData.type = "chokeBlock";
      interactiveObjects.push(chokeWheel);
      scene.add(chokeWheel);

      // Spool cut-away Ø®Ù„Ù Ø§Ù„Ù€ ADJ BEAN
      const spoolOuterGeo = new THREE.CylinderGeometry(0.45, 0.45, 1.6, 22);
      const spoolOuterMat = new THREE.MeshStandardMaterial({
        color: 0x4f4f4f,
        metalness: 0.8,
        roughness: 0.25
      });
      spoolOuter = new THREE.Mesh(spoolOuterGeo, spoolOuterMat);
      spoolOuter.rotation.z = Math.PI / 2;
      spoolOuter.position.set(6.4, 3.1, -1.8);
      spoolOuter.visible = false;
      scene.add(spoolOuter);

      const spoolInnerDirtyGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.5, 22);
      const spoolDirtyMat = new THREE.MeshStandardMaterial({
        color: 0x3b2415,
        roughness: 1.0,
        metalness: 0.1
      });
      spoolInnerDirty = new THREE.Mesh(spoolInnerDirtyGeo, spoolDirtyMat);
      spoolInnerDirty.rotation.z = Math.PI / 2;
      spoolInnerDirty.position.copy(spoolOuter.position);
      spoolInnerDirty.visible = false;
      scene.add(spoolInnerDirty);

      const spoolInnerCleanGeo = new THREE.CylinderGeometry(0.32, 0.32, 1.5, 22);
      const spoolCleanMat = new THREE.MeshStandardMaterial({
        color: 0xcfd8dc,
        metalness: 0.9,
        roughness: 0.25
      });
      spoolInnerClean = new THREE.Mesh(spoolInnerCleanGeo, spoolCleanMat);
      spoolInnerClean.rotation.z = Math.PI / 2;
      spoolInnerClean.position.copy(spoolOuter.position);
      spoolInnerClean.visible = false;
      scene.add(spoolInnerClean);

      // Ø®Ø· 6" Ù…Ù† Ø§Ù„Ù€ Choke Ø¥Ù„Ù‰ Ø§Ù„Ù€ Manifold (Ø«Ø®Ø§Ù†Ø© Ø£ÙƒØ¨Ø±)
      const exportLineGeo = new THREE.CylinderGeometry(0.30, 0.30, 10, 24);
      const exportLine = new THREE.Mesh(exportLineGeo, steelMat);
      exportLine.rotation.z = Math.PI / 2;
      exportLine.position.set(10.7, 3.1, 0);
      scene.add(exportLine);

      // MANIFOLD (Ù…Ø¨Ø³Ø· Ù…Ø«Ù„ Ø§Ù„ØµÙˆØ±Ø© Ø§Ù„Ø«Ø§Ù†ÙŠØ©)
      const manPadGeo = new THREE.BoxGeometry(12, 0.3, 3);
      const manPadMat = new THREE.MeshStandardMaterial({
        color: 0x8d8d8d,
        roughness: 0.8,
        metalness: 0.2
      });
      const manPad = new THREE.Mesh(manPadGeo, manPadMat);
      manPad.position.set(16, 0.15, 0);
      scene.add(manPad);

      const manLineGeo = new THREE.CylinderGeometry(0.30, 0.30, 6, 24);
      const manLine = new THREE.Mesh(manLineGeo, steelMat);
      manLine.rotation.z = Math.PI / 2;
      manLine.position.set(16, 1.2, 0);
      scene.add(manLine);

      // valve ÙÙŠ Ù…Ù†ØªØµÙ Ø§Ù„Ù…Ù†ÙŠ ÙÙˆÙ„Ø¯
      const manValveBodyGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.9, 20);
      const manValveBody = new THREE.Mesh(manValveBodyGeo, bluePipeMat);
      manValveBody.position.set(16, 1.6, 0);
      scene.add(manValveBody);

      const manWheelGeo = new THREE.TorusGeometry(0.9, 0.09, 16, 28);
      const manWheel = new THREE.Mesh(manWheelGeo, blueDarkMat);
      manWheel.position.set(16, 2.1, 0);
      manWheel.rotation.x = Math.PI / 2;
      scene.add(manWheel);

      // Drain Sample Ø¹Ù„Ù‰ Ø®Ø· 6" Ù‚Ø±ÙŠØ¨ Ù…Ù† Ø§Ù„Ù…Ù†ÙŠ ÙÙˆÙ„Ø¯
      const drainValveGeo = new THREE.SphereGeometry(0.3, 20, 20);
      const drainValveMat = new THREE.MeshStandardMaterial({
        color: 0x87cefa,
        metalness: 0.5,
        roughness: 0.3
      });
      const drainValve = new THREE.Mesh(drainValveGeo, drainValveMat);
      drainValve.position.set(14.8, 1.0, -1.0);
      drainValve.userData.type = "drain";
      interactiveObjects.push(drainValve);
      scene.add(drainValve);

      const drainLegGeo = new THREE.CylinderGeometry(0.1,0.1,1.2,10);
      const drainLeg = new THREE.Mesh(drainLegGeo, steelMat);
      drainLeg.position.set(14.8, 0.4, -1.0);
      scene.add(drainLeg);

      // Ù„ÙˆØ­Ø© Ù‚ÙŠØ§Ø³Ø§Øª 3D Ø¨Ø§Ù„Ù‚Ø±Ø¨ Ù…Ù† X-tree
      const gaugePanelGeo = new THREE.BoxGeometry(2.0, 1.2, 0.16);
      const gaugePanelMat = new THREE.MeshStandardMaterial({
        color: 0x111a26,
        emissive: 0x0b1628,
        roughness: 0.6
      });
      const gaugePanel3D = new THREE.Mesh(gaugePanelGeo, gaugePanelMat);
      gaugePanel3D.position.set(-6.0, 3.0, 3.5);
      gaugePanel3D.userData.type = "gauges3d";
      interactiveObjects.push(gaugePanel3D);
      scene.add(gaugePanel3D);

      const legGeo = new THREE.CylinderGeometry(0.09, 0.09, 2.0, 10);
      const legMat = new THREE.MeshStandardMaterial({
        color: 0x444444,
        roughness: 0.7
      });
      const leg1 = new THREE.Mesh(legGeo, legMat);
      leg1.position.set(-6.4, 2.0, 3.5);
      scene.add(leg1);
      const leg2 = leg1.clone();
      leg2.position.set(-5.6, 2.0, 3.5);
      scene.add(leg2);

      // Ø¹Ø§Ù…Ù„ 3D Ø¨Ø³ÙŠØ·
      createOperator();

      raycaster = new THREE.Raycaster();
      pointer = new THREE.Vector2();

      window.addEventListener("pointerdown", onPointerDown, false);
      window.addEventListener("resize", onWindowResize, false);

      updateObjective();
      updateGaugesText();
      setStatus("Ø§Ø¨Ø¯Ø£ Ø¨Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª Ø«Ù… Ø­Ø±Ù‘Ùƒ Ø§Ù„Ø¹Ø§Ù…Ù„ Ù„Ù„Ø¨Ø¦Ø±.", "#ffd27f");
    }

    function createOperator() {
      const group = new THREE.Group();

      const bodyMat = new THREE.MeshStandardMaterial({
        color: 0x1565c0,
        metalness: 0.4,
        roughness: 0.4
      });
      const headMat = new THREE.MeshStandardMaterial({
        color: 0xffe0bd,
        roughness: 0.6
      });
      const helmetMat = new THREE.MeshStandardMaterial({
        color: 0xffd54f,
        metalness: 0.4,
        roughness: 0.4
      });

      const legsGeo = new THREE.BoxGeometry(0.5, 0.8, 0.4);
      const legs = new THREE.Mesh(legsGeo, bodyMat);
      legs.position.set(0, 0.4, 0);
      group.add(legs);

      const bodyGeo = new THREE.BoxGeometry(0.6, 1.0, 0.45);
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.set(0, 1.3, 0);
      group.add(body);

      const headGeo = new THREE.SphereGeometry(0.25, 16, 16);
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.set(0, 2.0, 0);
      group.add(head);

      const helmetGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.18, 16);
      const helmet = new THREE.Mesh(helmetGeo, helmetMat);
      helmet.position.set(0, 2.2, 0);
      group.add(helmet);

      group.position.set(-5, 0, 2);
      scene.add(group);
      operator = group;
    }

    function onPointerDown(event) {
      if (!renderer) return;
      const rect = renderer.domElement.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;

      pointer.x = (x / rect.width) * 2 - 1;
      pointer.y = -(y / rect.height) * 2 + 1;

      raycaster.setFromCamera(pointer, camera);
      const intersects = raycaster.intersectObjects(interactiveObjects, true);
      if (intersects.length === 0) return;

      let obj = intersects[0].object;
      while (obj && !obj.userData.type && obj.parent) obj = obj.parent;
      if (!obj || !obj.userData.type) return;

      handleGameClick(obj.userData.type, obj);
    }

    function handleGameClick(type, obj) {
      if (type === "gauges3d") {
        if (gameStep === 0) {
          setStatus("Ù‚Ø±Ø§Ø¡Ø© WHP Ùˆ FLP Ù…Ù† Ù„ÙˆØ­Ø© Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª 3D...", "#ffd27f");
          updateGaugesText();
          gameStep = 1;
          updateObjective();
        } else {
          updateGaugesText();
          setStatus("ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù‚Ø±Ø§Ø¡Ø© Ù…Ù† Ù„ÙˆØ­Ø© Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª.", "#9effc0");
        }
        return;
      }

      // Ù„Ø§Ø²Ù… Ø§Ù„Ø¹Ø§Ù…Ù„ ÙŠÙƒÙˆÙ† Ù‚Ø±ÙŠØ¨
      if (!isOperatorNear(obj, 2.8)) {
        setStatus("Ù‚Ø±Ù‘Ø¨ Ø§Ù„Ø¹Ø§Ù…Ù„ Ù…Ù† Ù‡Ø°Ø§ Ø§Ù„Ø¬Ø²Ø¡ Ù‚Ø¨Ù„ Ø§Ù„Ø´ØºÙ„.", "#ff8080");
        return;
      }

      if (type === "upstream") {
        if (gameStep < 1) {
          setStatus("Ø§Ù‚Ø±Ø£ Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª Ø£ÙˆÙ„Ø§Ù‹ Ù‚Ø¨Ù„ Ø¥ØºÙ„Ø§Ù‚ ØµÙ…Ø§Ù… Upstream.", "#ff8080");
          return;
        }
        if (!upstreamClosed) {
          upstreamClosed = true;
          obj.material.color.set(0xc62828); // Ø£Ø­Ù…Ø± = Ù…ØºÙ„Ù‚
          setStatus("ØªÙ… Ø¥ØºÙ„Ø§Ù‚ ØµÙ…Ø§Ù… Upstream (Primary Wing Valve).", "#9effc0");
          if (gameStep === 1) {
            gameStep = 2;
            updateObjective();
          }
        } else {
          setStatus("ØµÙ…Ø§Ù… Upstream Ù…ØºÙ„Ù‚ Ø¨Ø§Ù„ÙØ¹Ù„.", "#cccccc");
        }
        return;
      }

      if (type === "chokeBlock") {
        if (gameStep < 2) {
          setStatus("Ø£ØºÙ„Ù‚ Upstream Ø£ÙˆÙ„Ø§Ù‹ Ø«Ù… ØªØ¹Ø§Ù…ÙÙ„ Ù…Ø¹ Ø§Ù„Ù€ ADJ BEAN.", "#ff8080");
          return;
        }

        if (!chokeOpened) {
          chokeOpened = true;
          if (spoolOuter) spoolOuter.visible = true;
          if (spoolInnerDirty) spoolInnerDirty.visible = true;
          if (spoolInnerClean) spoolInnerClean.visible = false;
          setStatus("ØªÙ… ÙØªØ­ Ø§Ù„Ù€ ADJ BEAN: Ø§Ù„Ø³Ø¨ÙˆÙ„ Ø¸Ø§Ù‡Ø± ÙˆÙÙŠÙ‡ Blockage.", "#ffd27f");
          if (gameStep === 2) {
            gameStep = 3;
            updateObjective();
          }
          return;
        }

        if (!blockageCleared) {
          blockageCleared = true;
          whp = 300;
          flp = 280;
          casingPressure = 55;
          if (spoolInnerDirty) spoolInnerDirty.visible = false;
          if (spoolInnerClean) spoolInnerClean.visible = true;
          obj.material.color.set(0x2e7d32); // Ø£Ø®Ø¶Ø± = Ù†Ø¸ÙŠÙ
          updateGaugesText();
          setStatus("ØªÙ… ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø³Ø¨ÙˆÙ„ ÙˆØ¥Ø²Ø§Ù„Ø© Ø§Ù„Ù€ Blockage.", "#9effc0");
          if (gameStep === 3) {
            gameStep = 4;
            updateObjective();
          }
          return;
        }

        setStatus("Ø§Ù„Ù€ ADJ BEAN ÙˆØ§Ù„Ø³Ø¨ÙˆÙ„ Ù†Ø¸ÙŠÙÙŠÙ† Ø­Ø§Ù„ÙŠØ§Ù‹.", "#cccccc");
        return;
      }

      if (type === "drain") {
        if (gameStep < 4) {
          setStatus("Ù†Ø¸Ù Ø§Ù„Ø³Ø¨ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹ Ù‚Ø¨Ù„ Ø£Ø®Ø° Drain Sample.", "#ff8080");
          return;
        }
        if (!sampleTaken) {
          sampleTaken = true;
          obj.material.color.set(0x00bcd4);

          const bottleGeo = new THREE.CylinderGeometry(0.18, 0.18, 0.7, 12);
          const bottleMat = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            metalness: 0.1,
            roughness: 0.2,
            transparent: true,
            opacity: 0.85
          });
          const bottle = new THREE.Mesh(bottleGeo, bottleMat);
          bottle.position.copy(obj.position);
          bottle.position.y -= 0.6;
          scene.add(bottle);

          setStatus("ØªÙ… Ø£Ø®Ø° Drain Sample Ù…Ù† Ø®Ø· 6\" Ø¨Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ù€ Manifold.", "#9effc0");
          completeTraining();
        } else {
          setStatus("Ø§Ù„Ø¹ÙŠÙ†Ø© Ù…Ø£Ø®ÙˆØ°Ø© Ø¨Ø§Ù„ÙØ¹Ù„ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ø¯ÙˆØ±Ø©.", "#cccccc");
        }
        return;
      }
    }

    function onWindowResize() {
      if (!camera || !renderer) return;
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      if (controls && renderer && scene && camera) {
        controls.update();
        renderer.render(scene, camera);
      }
    }

    window.addEventListener("load", function () {
      if (typeof THREE === "undefined" || typeof THREE.OrbitControls === "undefined") {
        debugMsg.style.display = "block";
        debugMsg.textContent = "Three.js Ø£Ùˆ OrbitControls Ù„Ù… ÙŠØªÙ… ØªØ­Ù…ÙŠÙ„Ù‡Ù…Ø§.";
        return;
      }
      try {
        initScene();
        animate();
      } catch (e) {
        debugMsg.style.display = "block";
        debugMsg.textContent = "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©: " + e.message;
      }
    });
  </script>
</body>
</html>
