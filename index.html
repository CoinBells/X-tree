<!DOCTYPE html>
<html lang="ar">
<head>
  <meta charset="UTF-8" />
  <title>ğŸ›¢ï¸ KOC X-Tree Training â€” Realistic 3D</title>
  <style>
    * { box-sizing: border-box; direction: rtl; }
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #11141f;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #fff;
    }
    canvas {
      position: fixed;
      inset: 0;
      display: block;
      z-index: 0;
    }
    #hud {
      position: fixed;
      top: 10px;
      right: 10px;
      width: 330px;
      max-width: 85vw;
      background: rgba(5, 7, 15, 0.9);
      border-radius: 12px;
      padding: 10px 13px;
      font-size: 13px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      backdrop-filter: blur(7px);
      z-index: 10;
    }
    #hud h1 { font-size: 15px; margin: 0 0 3px 0; }
    #hud p  { margin: 3px 0; }
    #hud small { opacity: 0.75; }
    #objectiveText { margin-top: 4px; font-weight: 600; color: #ffd27f; }
    #steps { list-style: none; padding: 0; margin: 4px 0 2px 0; }
    #steps li { margin: 1px 0; font-size: 12px; }
    .pending::before { content: "â—‹ "; color: #999; }
    .active::before  { content: "â— "; color: #ffd27f; }
    .done::before    { content: "âœ” "; color: #4caf50; }

    #gaugesPanel {
      margin-top: 5px;
      padding: 6px 8px;
      border-radius: 8px;
      background: radial-gradient(circle at top, #2a324a, #121420);
      border: 1px solid rgba(255, 255, 255, 0.12);
      cursor: pointer;
    }
    #gaugesPanel h3 { margin: 0 0 3px 0; font-size: 13px; }
    #gaugesPanel p  { margin: 1px 0; font-size: 12px; }

    #statusBar {
      margin-top: 5px;
      font-size: 12px;
      color: #9effc0;
      min-height: 16px;
    }
    #hint {
      margin-top: 3px;
      font-size: 11px;
      color: #b6b6b6;
    }

    #completeOverlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.78);
      z-index: 20;
    }
    #completeOverlay .box {
      padding: 18px 22px;
      background: #0c101f;
      border-radius: 16px;
      text-align: center;
      border: 1px solid #4caf50;
      box-shadow: 0 0 28px rgba(0,0,0,0.7);
      max-width: 90vw;
    }
    #completeOverlay h2 { margin: 0 0 6px 0; font-size: 18px; }
    #completeOverlay p  { margin: 4px 0; font-size: 13px; }
    #completeOverlay button {
      margin-top: 10px;
      padding: 6px 15px;
      border-radius: 999px;
      border: none;
      background: #4caf50;
      color: #fff;
      cursor: pointer;
      font-weight: 600;
      font-size: 13px;
    }
    #completeOverlay button:hover { background: #3f9144; }

    #debugMsg {
      position: fixed;
      bottom: 8px;
      left: 8px;
      padding: 6px 10px;
      background: rgba(160, 30, 30, 0.95);
      color: #fff;
      font-size: 11px;
      border-radius: 6px;
      z-index: 30;
      display: none;
    }

    @media (max-width: 600px) {
      #hud { left: 10px; width: auto; }
      #hud h1 { font-size: 14px; }
    }
  </style>
</head>
<body>
  <div id="hud">
    <h1>ğŸ›¢ï¸ KOC X-Tree Training â€” 3D ÙˆØ§Ù‚Ø¹ÙŠ</h1>
    <p><small>Ù…Ø­Ø§ÙƒØ§Ø© ÙˆØ§Ù‚Ø¹ÙŠØ© Ù„Ø´Ø¬Ø±Ø© Ø§Ù„Ø¨Ø¦Ø± ÙˆØ§Ù„Ù€ Hook-Up Ù„ØªØ¯Ø±ÙŠØ¨ Ø§Ù„ÙÙŠÙ„Ø¯ Ø£ÙˆØ¨Ø±ÙŠØªØ± Ø¹Ù„Ù‰ WHP / FLP / Choke / Drain Sample.</small></p>
    <p id="objectiveText"></p>
    <ul id="steps">
      <li id="step1" class="active">1- Ù‚Ø±Ø§Ø¡Ø© WHP &amp; FLP Ù…Ù† Ø´Ø§Ø´Ø© Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª</li>
      <li id="step2" class="pending">2- Ø¥ØºÙ„Ø§Ù‚ ØµÙ…Ø§Ù… Upstream Ù‚Ø¨Ù„ Ø§Ù„Ø´ØºÙ„</li>
      <li id="step3" class="pending">3- ÙØªØ­ ÙˆÙØ­Øµ Ø§Ù„Ù€ ADJ BEAN ÙˆØ±Ø¤ÙŠØ© Ø§Ù„Ø³Ø¨ÙˆÙ„</li>
      <li id="step4" class="pending">4- ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø³Ø¨ÙˆÙ„ ÙˆØ£Ø®Ø° Drain Sample Ù…Ù† Ø®Ø· Ø§Ù„Ù€ Hook-Up</li>
    </ul>

    <div id="gaugesPanel">
      <h3>ğŸ“Ÿ Ø´Ø§Ø´Ø© Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª (Ø§Ø¶ØºØ· Ù„Ù„Ù‚Ø±Ø§Ø¡Ø©)</h3>
      <p id="gaugeValues">WHP: --- psi | FLP: --- psi | CASING: --- psi</p>
      <p id="gaugeStatus">Ø§Ù„Ø­Ø§Ù„Ø©: â€”</p>
    </div>

    <div id="statusBar"></div>
    <div id="hint">
      Ø§Ø³Ø­Ø¨ Ø¨Ø¥ØµØ¨Ø¹Ùƒ Ù„ØªØ¯ÙˆÙŠØ± Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ØŒ Ù‚Ø±Ù‘Ø¨/Ø£Ø¨Ø¹Ø¯ Ø¨Ø¥ØµØ¨Ø¹ÙŠÙ† (Zoom)ØŒ ÙˆØ§Ø¶ØºØ· Ø¹Ù„Ù‰:
      ØµÙ…Ø§Ù… Ø§Ù„Ø¬Ù†Ø§Ø­ Ø§Ù„Ø£Ø®Ø¶Ø± (Upstream)ØŒ Ø¨Ù„ÙˆÙƒ Ø§Ù„Ù€ ADJ BEAN Ø§Ù„Ø£Ø²Ø±Ù‚ØŒ ÙˆØµÙ…Ø§Ù… Drain Sample.
    </div>
  </div>

  <div id="completeOverlay">
    <div class="box">
      <h2>âœ… Ø§Ù„ØªØ¯Ø±ÙŠØ¨ Ø§ÙƒØªÙ…Ù„ Ø¨Ù†Ø¬Ø§Ø­</h2>
      <p>ÙØªØ­Øª Ø§Ù„Ù€ ADJ BEANØŒ Ø´ÙØª Ø§Ù„Ø³Ø¨ÙˆÙ„ ÙˆØ§Ù„Ù€ BlockageØŒ Ù†Ø¸Ù‘ÙØªÙ‡ ÙˆØ£Ø®Ø°Øª Drain Sample Ø¨Ø£Ù…Ø§Ù†.</p>
      <button onclick="restartTraining()">Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ¬Ø±Ø¨Ø©</button>
    </div>
  </div>

  <div id="debugMsg"></div>

  <!-- Three.js Ù†Ø³Ø®Ø© ØªØ¯Ø¹Ù… OrbitControls ÙƒÙ€ global -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.140.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    let scene, camera, renderer, controls;
    let raycaster, pointer;
    const interactiveObjects = [];

    let gameStep = 0;
    let whp = 360;
    let flp = 35;
    let casingPressure = 0;

    let blockageCleared = false; // Ø¨Ø¹Ø¯ ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø³Ø¨ÙˆÙ„
    let upstreamClosed = false;
    let sampleTaken   = false;

    let chokeOpened   = false;   // ÙØªØ­ Ø¬Ø³Ù… Ø§Ù„Ù€ ADJ BEAN Ù„Ø±Ø¤ÙŠØ© Ø§Ù„Ø³Ø¨ÙˆÙ„

    // Ù…Ø¬Ø³Ù…Ø§Øª Ø§Ù„Ø³Ø¨ÙˆÙ„ (inspection)
    let spoolOuter, spoolInnerDirty, spoolInnerClean;

    const objectiveText   = document.getElementById("objectiveText");
    const gaugeValues     = document.getElementById("gaugeValues");
    const gaugeStatus     = document.getElementById("gaugeStatus");
    const statusBar       = document.getElementById("statusBar");
    const completeOverlay = document.getElementById("completeOverlay");
    const debugMsg        = document.getElementById("debugMsg");

    const stepEls = {
      1: document.getElementById("step1"),
      2: document.getElementById("step2"),
      3: document.getElementById("step3"),
      4: document.getElementById("step4")
    };

    function setStepState(step, state) { stepEls[step].className = state; }

    function updateObjective() {
      switch (gameStep) {
        case 0:
          objectiveText.textContent =
            "Ø§Ø¨Ø¯Ø£ Ø¨Ù‚Ø±Ø§Ø¡Ø© WHP Ùˆ FLP Ù…Ù† Ø´Ø§Ø´Ø© Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª Ù„ØªØ´Ø®ÙŠØµ ÙˆØ¬ÙˆØ¯ Blockage Ø¹Ù„Ù‰ Ø§Ù„Ù€ Choke.";
          setStepState(1, "active");
          setStepState(2, "pending");
          setStepState(3, "pending");
          setStepState(4, "pending");
          break;
        case 1:
          objectiveText.textContent =
            "Ø£ØºÙ„Ù‚ ØµÙ…Ø§Ù… Upstream (Ø§Ù„Ø¬Ù†Ø§Ø­ Ø§Ù„Ø£Ø®Ø¶Ø± Ø¹Ù„Ù‰ Ø§Ù„ÙŠÙ…ÙŠÙ†) Ù‚Ø¨Ù„ Ø§Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ù€ ADJ BEAN.";
          setStepState(1, "done");
          setStepState(2, "active");
          break;
        case 2:
          objectiveText.textContent =
            "Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Ø¨Ù„ÙˆÙƒ Ø§Ù„Ù€ ADJ BEAN Ø§Ù„Ø£Ø²Ø±Ù‚ Ù„ÙØªØ­Ù‡ ÙˆØ±Ø¤ÙŠØ© Ø§Ù„Ø³Ø¨ÙˆÙ„ Ù…Ù† Ø§Ù„Ø¯Ø§Ø®Ù„ (Ù…Ø¹ Ø§Ù„Ù€ Blockage).";
          setStepState(2, "done");
          setStepState(3, "active");
          break;
        case 3:
          objectiveText.textContent =
            "Ø§Ø¶ØºØ· Ù…Ø±Ø© Ø£Ø®Ø±Ù‰ Ø¹Ù„Ù‰ Ø§Ù„Ù€ ADJ BEAN Ù„ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø³Ø¨ÙˆÙ„ (Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ù€ Blockage) Ø«Ù… Ø®Ø° Drain Sample.";
          setStepState(3, "active");
          break;
        case 4:
          objectiveText.textContent =
            "Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ ØµÙ…Ø§Ù… Drain Sample ÙÙŠ Ø®Ø· Ø§Ù„Ù€ Hook-Up Ù„Ø£Ø®Ø° Ø§Ù„Ø¹ÙŠÙ†Ø© ÙˆØ¥Ù†Ù‡Ø§Ø¡ Ø§Ù„ØªØ¯Ø±ÙŠØ¨.";
          setStepState(3, "done");
          setStepState(4, "active");
          break;
        case 5:
          objectiveText.textContent =
            "Ø§Ù„ØªØ¯Ø±ÙŠØ¨ Ù…ÙƒØªÙ…Ù„ØŒ ÙŠÙ…ÙƒÙ†Ùƒ Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ¬Ø±Ø¨Ø© Ø£Ùˆ Ø§Ø³ØªÙƒØ´Ø§Ù Ø§Ù„Ù€ X-Tree ÙÙŠ ÙˆØ¶Ø¹ Ø­Ø±.";
          setStepState(4, "done");
          break;
      }
    }

    function updateGaugesText() {
      gaugeValues.textContent =
        "WHP: " + whp.toFixed(0) +
        " psi | FLP: " + flp.toFixed(0) +
        " psi | CASING: " + casingPressure.toFixed(0) + " psi";

      if (!blockageCleared) {
        gaugeStatus.textContent =
          "Ø§Ù„Ø­Ø§Ù„Ø©: Ø§Ø­ØªÙ…Ø§Ù„ Blockage Ø¹Ù„Ù‰ Ø§Ù„Ù€ Choke (ÙØ±Ù‚ ÙƒØ¨ÙŠØ± Ø¨ÙŠÙ† WHP Ùˆ FLP).";
      } else {
        gaugeStatus.textContent =
          "Ø§Ù„Ø­Ø§Ù„Ø©: Ø§Ù„ØªØ¯ÙÙ‚ Ø·Ø¨ÙŠØ¹ÙŠ Ø¨Ø¹Ø¯ ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø³Ø¨ÙˆÙ„ ÙˆØ§Ù„Ù€ Choke (FLP Ù‚Ø±ÙŠØ¨ Ù…Ù† WHP).";
      }
    }

    function setStatus(msg, color) {
      statusBar.textContent = msg || "";
      statusBar.style.color = color || "#9effc0";
    }

    function completeTraining() {
      gameStep = 5;
      updateObjective();
      completeOverlay.style.display = "flex";
      setStatus("Ø§ÙƒØªÙ…Ù„ Ø§Ù„ØªØ¯Ø±ÙŠØ¨. Ù…Ù…ØªØ§Ø².", "#9effc0");
    }

    function restartTraining() {
      completeOverlay.style.display = "none";
      gameStep = 0;
      whp = 360;
      flp = 35;
      casingPressure = 0;
      blockageCleared = false;
      upstreamClosed = false;
      sampleTaken = false;
      chokeOpened = false;

      // Ø£Ù„ÙˆØ§Ù† Ø¥Ø¹Ø§Ø¯Ø© Ø¶Ø¨Ø·
      interactiveObjects.forEach(obj => {
        if (obj.userData.type === "upstream") obj.material.color.set(0x00b894); // Ø£Ø®Ø¶Ø±
        if (obj.userData.type === "chokeBlock")    obj.material.color.set(0x124d92); // Ø£Ø²Ø±Ù‚
      });

      if (spoolOuter) spoolOuter.visible = false;
      if (spoolInnerDirty) spoolInnerDirty.visible = false;
      if (spoolInnerClean) spoolInnerClean.visible = false;

      updateObjective();
      updateGaugesText();
      setStatus("ØªÙ…Øª Ø¥Ø¹Ø§Ø¯Ø© Ø¶Ø¨Ø· Ø§Ù„ØªØ¯Ø±ÙŠØ¨.", "#9effc0");
    }

    document.getElementById("gaugesPanel").addEventListener("click", () => {
      if (gameStep === 0) {
        setStatus("Ù‚Ø±Ø§Ø¡Ø© WHP Ùˆ FLP Ù…Ù† Ø´Ø§Ø´Ø© Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª...", "#ffd27f");
        updateGaugesText();
        gameStep = 1;
        updateObjective();
      } else {
        updateGaugesText();
        setStatus("ØªÙ… ØªØ­Ø¯ÙŠØ« Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª.", "#9effc0");
      }
    });

    function initScene() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xb9e4ff);

      camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        200
      );
      camera.position.set(10, 7, 15);

      renderer = new THREE.WebGLRenderer({ antialias: false });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio * 0.8, 1.6));
      document.body.appendChild(renderer.domElement);
      renderer.domElement.style.position = "fixed";
      renderer.domElement.style.inset = "0";
      renderer.domElement.style.zIndex = "0";

      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 3.2, 0);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.minDistance = 7;
      controls.maxDistance = 35;
      controls.maxPolarAngle = Math.PI / 2.1;
      controls.update();

      const hemiLight = new THREE.HemisphereLight(0xffffee, 0xb89b6a, 0.7);
      hemiLight.position.set(0, 40, 0);
      scene.add(hemiLight);

      const sun = new THREE.DirectionalLight(0xffffff, 1.0);
      sun.position.set(25, 35, 10);
      scene.add(sun);

      // Ø£Ø±Ø¶ÙŠØ© ØµØ­Ø±Ø§ÙˆÙŠØ©
      const groundGeo = new THREE.PlaneGeometry(120, 120, 32, 32);
      const groundMat = new THREE.MeshStandardMaterial({
        color: 0xd8be8e,
        roughness: 0.95,
        metalness: 0.0
      });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = 0;
      scene.add(ground);

      // ØªÙ„Ø§Ù„ Ø¨Ø³ÙŠØ·Ø©
      for (let i = 0; i < 18; i++) {
        const hillGeo = new THREE.ConeGeometry(
          0.8 + Math.random() * 1.8,
          0.7 + Math.random() * 1.3,
          6
        );
        const hillMat = new THREE.MeshStandardMaterial({
          color: 0xcfa471,
          roughness: 1.0
        });
        const hill = new THREE.Mesh(hillGeo, hillMat);
        hill.position.set(
          (Math.random() - 0.5) * 80,
          0.45,
          (Math.random() - 0.5) * 80
        );
        hill.rotation.y = Math.random() * Math.PI;
        scene.add(hill);
      }

      // Ù…Ù†ØµØ©
      const padGeo = new THREE.BoxGeometry(10, 0.4, 10);
      const padMat = new THREE.MeshStandardMaterial({
        color: 0x9c9c9c,
        roughness: 0.8,
        metalness: 0.1
      });
      const pad = new THREE.Mesh(padGeo, padMat);
      pad.position.set(0, 0.2, 0);
      scene.add(pad);

      // Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø´Ø¬Ø±Ø©
      const baseGeo = new THREE.CylinderGeometry(1.2, 1.4, 0.6, 16);
      const baseMat = new THREE.MeshStandardMaterial({
        color: 0x5b6067,
        metalness: 0.5,
        roughness: 0.4
      });
      const base = new THREE.Mesh(baseGeo, baseMat);
      base.position.set(0, 0.7, 0);
      scene.add(base);

      // Ø£Ù†Ø¨ÙˆØ¨ Ø±Ø£Ø³ÙŠ
      const vertGeo = new THREE.CylinderGeometry(0.35, 0.35, 4.8, 18);
      const vertMat = new THREE.MeshStandardMaterial({
        color: 0x9b9b9b,
        metalness: 0.55,
        roughness: 0.35
      });
      const vertPipe = new THREE.Mesh(vertGeo, vertMat);
      vertPipe.position.set(0, 3.1, 0);
      scene.add(vertPipe);

      // Swab cap Ø£Ø¹Ù„Ù‰ Ù…Ø«Ù„ Ø§Ù„ØµÙˆØ±Ø©
      const swabBodyGeo = new THREE.CylinderGeometry(0.4, 0.4, 0.5, 16);
      const swabBodyMat = new THREE.MeshStandardMaterial({
        color: 0xb0b0b0,
        metalness: 0.7,
        roughness: 0.2
      });
      const swabBody = new THREE.Mesh(swabBodyGeo, swabBodyMat);
      swabBody.position.set(0, 5.0, 0);
      scene.add(swabBody);

      const swabCapGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.25, 16);
      const swabCap = new THREE.Mesh(swabCapGeo, swabBodyMat);
      swabCap.position.set(0, 5.3, 0);
      scene.add(swabCap);

      // Ù…Ø§Ø¯Ø© ØµØ¯Ø£
      const rustMat = new THREE.MeshStandardMaterial({
        color: 0x8a4c2c,
        metalness: 0.3,
        roughness: 0.85
      });

      // ØµÙ…Ø§Ù… + Ù‡Ø§Ù†Ø¯ ÙˆÙŠÙ„
      function createRustValve(y, xOffset, options = {}) {
        const group = new THREE.Group();

        const valveBodyGeo = new THREE.CylinderGeometry(0.45, 0.45, 0.5, 18);
        const valveBody = new THREE.Mesh(valveBodyGeo, rustMat);
        valveBody.position.set(xOffset, y, 0);
        valveBody.rotation.z = Math.PI / 2;
        group.add(valveBody);

        const wheelGeo = new THREE.TorusGeometry(
          options.radius || 0.9,
          0.09,
          14,
          26
        );
        const wheel = new THREE.Mesh(wheelGeo, rustMat);
        wheel.position.set(xOffset, y, 0);
        wheel.rotation.x = Math.PI / 2;
        group.add(wheel);

        const stemGeo = new THREE.CylinderGeometry(0.12, 0.12, 0.7, 12);
        const stem = new THREE.Mesh(stemGeo, rustMat);
        stem.position.set(xOffset, y + 0.55, 0);
        group.add(stem);

        scene.add(group);
        return { group, wheel, valveBody };
      }

      // 3 master valves Ø±Ø£Ø³ÙŠØ© Ù…Ø«Ù„ Ø§Ù„ØµÙˆØ±Ø©
      createRustValve(4.2, 0, { radius: 1.0 }); // upper
      createRustValve(3.1, 0, { radius: 1.0 }); // middle
      createRustValve(2.0, 0, { radius: 1.0 }); // lower

      // Ø£Ø°Ø±Ø¹ Ø¬Ø§Ù†Ø¨ÙŠØ© Ø±Ø¦ÙŠØ³ÙŠØ©
      const armGeo = new THREE.CylinderGeometry(0.26, 0.26, 3.6, 18);
      const armMat = new THREE.MeshStandardMaterial({
        color: 0xb3b3b3,
        metalness: 0.6,
        roughness: 0.3
      });

      const leftArm = new THREE.Mesh(armGeo, armMat);
      leftArm.rotation.z = Math.PI / 2;
      leftArm.position.set(-1.9, 3.1, 0);
      scene.add(leftArm);

      const rightArm = new THREE.Mesh(armGeo, armMat);
      rightArm.rotation.z = Math.PI / 2;
      rightArm.position.set(1.9, 3.1, 0);
      scene.add(rightArm);

      // ØµÙ…Ø§Ù… Ø¬Ø§Ù†Ø¨ÙŠ ÙŠØ³Ø§Ø± Ù…Ø«Ù„ Ø§Ù„ØµÙˆØ±Ø©
      createRustValve(3.1, -3.3, { radius: 1.0 });

      // Upstream valve ÙŠÙ…ÙŠÙ† (ØªÙØ§Ø¹Ù„ÙŠ) Ø¨Ø´ÙƒÙ„ Ø¬Ù†Ø§Ø­ Ø£Ø®Ø¶Ø±
      const upValveBodyGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.6, 18);
      const upValveMat = new THREE.MeshStandardMaterial({
        color: 0x00b894,
        metalness: 0.7,
        roughness: 0.35
      });
      const upstreamValve = new THREE.Mesh(upValveBodyGeo, upValveMat);
      upstreamValve.position.set(3.3, 3.1, 0);
      upstreamValve.rotation.z = Math.PI / 2;
      upstreamValve.userData.type = "upstream";
      interactiveObjects.push(upstreamValve);
      scene.add(upstreamValve);

      const upWheelGeo = new THREE.TorusGeometry(0.85, 0.09, 14, 26);
      const upWheelMat = new THREE.MeshStandardMaterial({
        color: 0xe8f5e9,
        metalness: 0.6,
        roughness: 0.25
      });
      const upWheel = new THREE.Mesh(upWheelGeo, upWheelMat);
      upWheel.position.set(3.3, 3.1, 0);
      upWheel.rotation.x = Math.PI / 2;
      upWheel.userData.type = "upstream";
      interactiveObjects.push(upWheel);
      scene.add(upWheel);

      // Hook-Up / Flowline assembly (Ø£Ø²Ø±Ù‚ + Ø³Ø¨ÙˆÙ„)

      const lineSteelMat = new THREE.MeshStandardMaterial({
        color: 0xd0d8e0,
        metalness: 0.75,
        roughness: 0.25
      });

      const line1Geo = new THREE.CylinderGeometry(0.2, 0.2, 3.0, 18);
      const line1 = new THREE.Mesh(line1Geo, lineSteelMat);
      line1.rotation.z = Math.PI / 2;
      line1.position.set(4.8, 3.1, 0);
      scene.add(line1);

      const chokeBlockGeo = new THREE.BoxGeometry(1.7, 1.0, 1.1);
      const chokeBlockMat = new THREE.MeshStandardMaterial({
        color: 0x124d92,
        metalness: 0.7,
        roughness: 0.35
      });
      const chokeBlock = new THREE.Mesh(chokeBlockGeo, chokeBlockMat);
      chokeBlock.position.set(6.4, 3.1, 0);
      chokeBlock.userData.type = "chokeBlock";
      interactiveObjects.push(chokeBlock);
      scene.add(chokeBlock);

      const chokeWheel = new THREE.Mesh(
        new THREE.TorusGeometry(0.7, 0.08, 12, 24),
        new THREE.MeshStandardMaterial({
          color: 0xf5f5f5,
          metalness: 0.7,
          roughness: 0.25
        })
      );
      chokeWheel.position.set(6.4, 3.6, 0.55);
      chokeWheel.rotation.y = Math.PI / 2;
      chokeWheel.userData.type = "chokeBlock";
      interactiveObjects.push(chokeWheel);
      scene.add(chokeWheel);

      // Ø³Ø¨ÙˆÙ„ Ù…Ù‚Ø·ÙˆØ¹ (Inspection) Ø®Ù„Ù Ø§Ù„Ø¨Ù„ÙˆÙƒ Ù‚Ù„ÙŠÙ„Ø§Ù‹
      const spoolOuterGeo = new THREE.CylinderGeometry(0.45, 0.45, 1.6, 22);
      const spoolOuterMat = new THREE.MeshStandardMaterial({
        color: 0x4f4f4f,
        metalness: 0.8,
        roughness: 0.25
      });
      spoolOuter = new THREE.Mesh(spoolOuterGeo, spoolOuterMat);
      spoolOuter.rotation.z = Math.PI / 2;
      spoolOuter.position.set(6.4, 3.1, -1.8);
      spoolOuter.visible = false;
      scene.add(spoolOuter);

      const spoolInnerDirtyGeo = new THREE.CylinderGeometry(0.3, 0.3, 1.5, 22);
      const spoolDirtyMat = new THREE.MeshStandardMaterial({
        color: 0x3b2415,  // Ø²ÙŠØª + deposits
        roughness: 1.0,
        metalness: 0.1
      });
      spoolInnerDirty = new THREE.Mesh(spoolInnerDirtyGeo, spoolDirtyMat);
      spoolInnerDirty.rotation.z = Math.PI / 2;
      spoolInnerDirty.position.copy(spoolOuter.position);
      spoolInnerDirty.visible = false;
      scene.add(spoolInnerDirty);

      const spoolInnerCleanGeo = new THREE.CylinderGeometry(0.32, 0.32, 1.5, 22);
      const spoolCleanMat = new THREE.MeshStandardMaterial({
        color: 0xcfd8dc,
        metalness: 0.9,
        roughness: 0.25
      });
      spoolInnerClean = new THREE.Mesh(spoolInnerCleanGeo, spoolCleanMat);
      spoolInnerClean.rotation.z = Math.PI / 2;
      spoolInnerClean.position.copy(spoolOuter.position);
      spoolInnerClean.visible = false;
      scene.add(spoolInnerClean);

      // Ø§Ù„Ø®Ø· Ø§Ù„Ù†Ø§Ø²Ù„ Ø¨Ø¹Ø¯ Ø§Ù„Ù€ choke
      const downGeo = new THREE.CylinderGeometry(0.18, 0.18, 2.6, 16);
      const downPipe = new THREE.Mesh(downGeo, lineSteelMat);
      downPipe.position.set(7.8, 2.0, 0);
      scene.add(downPipe);

      const elbowGeo = new THREE.TorusGeometry(0.18, 0.08, 10, 18, Math.PI / 2);
      const elbow = new THREE.Mesh(elbowGeo, lineSteelMat);
      elbow.position.set(7.8, 0.7, 0);
      elbow.rotation.z = Math.PI / 2;
      scene.add(elbow);

      const hookLineGeo = new THREE.CylinderGeometry(0.18, 0.18, 4.5, 16);
      const hookLine = new THREE.Mesh(hookLineGeo, lineSteelMat);
      hookLine.rotation.z = Math.PI / 2;
      hookLine.position.set(10.0, 0.7, -1.0);
      scene.add(hookLine);

      // Drain Sample valve
      const drainValveGeo = new THREE.SphereGeometry(0.3, 20, 20);
      const drainValveMat = new THREE.MeshStandardMaterial({
        color: 0x87cefa,
        metalness: 0.5,
        roughness: 0.3
      });
      const drainValve = new THREE.Mesh(drainValveGeo, drainValveMat);
      drainValve.position.set(11.8, 0.7, -1.0);
      drainValve.userData.type = "drain";
      interactiveObjects.push(drainValve);
      scene.add(drainValve);

      // Ù„ÙˆØ­Ø© Ù‚ÙŠØ§Ø³Ø§Øª 3D
      const gaugePanelGeo = new THREE.BoxGeometry(2.0, 1.2, 0.16);
      const gaugePanelMat = new THREE.MeshStandardMaterial({
        color: 0x111a26,
        emissive: 0x0b1628,
        roughness: 0.6
      });
      const gaugePanel3D = new THREE.Mesh(gaugePanelGeo, gaugePanelMat);
      gaugePanel3D.position.set(-6.0, 3.0, 3.5);
      gaugePanel3D.userData.type = "gauges3d";
      interactiveObjects.push(gaugePanel3D);
      scene.add(gaugePanel3D);

      const legGeo = new THREE.CylinderGeometry(0.09, 0.09, 2.0, 10);
      const legMat = new THREE.MeshStandardMaterial({
        color: 0x444444,
        roughness: 0.7
      });
      const leg1 = new THREE.Mesh(legGeo, legMat);
      leg1.position.set(-6.4, 2.0, 3.5);
      scene.add(leg1);
      const leg2 = leg1.clone();
      leg2.position.set(-5.6, 2.0, 3.5);
      scene.add(leg2);

      raycaster = new THREE.Raycaster();
      pointer = new THREE.Vector2();

      window.addEventListener("pointerdown", onPointerDown, false);
      window.addEventListener("resize", onWindowResize, false);

      updateObjective();
      updateGaugesText();
      setStatus("Ø§Ø¨Ø¯Ø£ Ø¨Ù‚Ø±Ø§Ø¡Ø© WHP Ùˆ FLP Ù…Ù† Ø´Ø§Ø´Ø© Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª (HUD Ø£Ùˆ Ù„ÙˆØ­Ø© 3D).", "#ffd27f");
    }

    function onPointerDown(event) {
      if (!renderer) return;
      const rect = renderer.domElement.getBoundingClientRect();
      const x = event.clientX - rect.left;
      const y = event.clientY - rect.top;

      pointer.x = (x / rect.width) * 2 - 1;
      pointer.y = -(y / rect.height) * 2 + 1;

      raycaster.setFromCamera(pointer, camera);
      const intersects = raycaster.intersectObjects(interactiveObjects, true);
      if (intersects.length === 0) return;

      let obj = intersects[0].object;
      while (obj && !obj.userData.type && obj.parent) obj = obj.parent;
      if (!obj || !obj.userData.type) return;

      handleGameClick(obj.userData.type, obj);
    }

    function handleGameClick(type, obj) {
      if (type === "gauges3d") {
        if (gameStep === 0) {
          setStatus("Ù‚Ø±Ø§Ø¡Ø© WHP Ùˆ FLP Ù…Ù† Ù„ÙˆØ­Ø© Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª 3D...", "#ffd27f");
          updateGaugesText();
          gameStep = 1;
          updateObjective();
        } else {
          updateGaugesText();
          setStatus("ØªÙ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù‚Ø±Ø§Ø¡Ø© Ù…Ù† Ù„ÙˆØ­Ø© Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª.", "#9effc0");
        }
        return;
      }

      if (type === "upstream") {
        if (gameStep < 1) {
          setStatus("Ø§Ù‚Ø±Ø£ Ø§Ù„Ù‚ÙŠØ§Ø³Ø§Øª Ø£ÙˆÙ„Ø§Ù‹ Ù‚Ø¨Ù„ Ø¥ØºÙ„Ø§Ù‚ ØµÙ…Ø§Ù… Upstream.", "#ff8080");
          return;
        }
        if (!upstreamClosed) {
          upstreamClosed = true;
          obj.material.color.set(0xe53935); // Ø£Ø­Ù…Ø± = Ù…ØºÙ„Ù‚
          setStatus("ØªÙ… Ø¥ØºÙ„Ø§Ù‚ ØµÙ…Ø§Ù… Upstream Ø¨Ù†Ø¬Ø§Ø­.", "#9effc0");
          if (gameStep === 1) {
            gameStep = 2;
            updateObjective();
          }
        } else {
          setStatus("ØµÙ…Ø§Ù… Upstream Ù…ØºÙ„Ù‚ Ø¨Ø§Ù„ÙØ¹Ù„.", "#cccccc");
        }
        return;
      }

      if (type === "chokeBlock") {
        if (gameStep < 2) {
          setStatus("Ø£ØºÙ„Ù‚ Upstream Ø£ÙˆÙ„Ø§Ù‹ Ø«Ù… ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„Ù€ ADJ BEAN.", "#ff8080");
          return;
        }

        // Ø£ÙˆÙ„ Ø¶ØºØ·Ø©: ÙØªØ­ Ø§Ù„Ù€ ADJ BEAN ÙˆØ¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ø³Ø¨ÙˆÙ„ Ø¨Ù€ Blockage
        if (!chokeOpened) {
          chokeOpened = true;
          if (spoolOuter) spoolOuter.visible = true;
          if (spoolInnerDirty) spoolInnerDirty.visible = true;
          if (spoolInnerClean) spoolInnerClean.visible = false;
          setStatus("ØªÙ… ÙØªØ­ Ø§Ù„Ù€ ADJ BEAN: Ø§Ù„Ø³Ø¨ÙˆÙ„ Ø¸Ø§Ù‡Ø± ÙˆÙÙŠÙ‡ Blockage ÙˆØ§Ø¶Ø­.", "#ffd27f");
          if (gameStep === 2) {
            gameStep = 3;
            updateObjective();
          }
          return;
        }

        // Ø«Ø§Ù†ÙŠ Ø¶ØºØ·Ø©: ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø³Ø¨ÙˆÙ„ ÙˆØªØºÙŠÙŠØ± Ø§Ù„Ù‚Ø±Ø§Ø¡Ø§Øª
        if (!blockageCleared) {
          blockageCleared = true;
          whp = 300;
          flp = 280;
          casingPressure = 55;
          if (spoolInnerDirty) spoolInnerDirty.visible = false;
          if (spoolInnerClean) spoolInnerClean.visible = true;
          obj.material.color.set(0x1b5e20); // Ø£Ø®Ø¶Ø± ØºØ§Ù…Ù‚ = clean / OK
          updateGaugesText();
          setStatus("ØªÙ… ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø³Ø¨ÙˆÙ„ ÙˆØ¥Ø²Ø§Ù„Ø© Ø§Ù„Ù€ BlockageØŒ Ø§Ù„ØªØ¯ÙÙ‚ Ø±Ø¬Ø¹ Ø·Ø¨ÙŠØ¹ÙŠ.", "#9effc0");
          if (gameStep === 3) {
            gameStep = 4;
            updateObjective();
          }
          return;
        }

        // Ø¨Ø¹Ø¯ Ù…Ø§ ÙŠÙ†Ø¸Ù
        setStatus("Ø§Ù„Ù€ ADJ BEAN ÙˆØ§Ù„Ø³Ø¨ÙˆÙ„ Ù†Ø¸ÙŠÙÙŠÙ† Ø­Ø§Ù„ÙŠØ§Ù‹.", "#cccccc");
        return;
      }

      if (type === "drain") {
        if (gameStep < 4) {
          setStatus("Ù†Ø¸Ù Ø§Ù„Ø³Ø¨ÙˆÙ„ Ø£ÙˆÙ„Ø§Ù‹ØŒ Ø¨Ø¹Ø¯Ù‡Ø§ Ø®Ø° Drain Sample.", "#ff8080");
          return;
        }
        if (!sampleTaken) {
          sampleTaken = true;
          obj.material.color.set(0x00bcd4);

          const bottleGeo = new THREE.CylinderGeometry(0.18, 0.18, 0.7, 12);
          const bottleMat = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            metalness: 0.1,
            roughness: 0.2,
            transparent: true,
            opacity: 0.85
          });
          const bottle = new THREE.Mesh(bottleGeo, bottleMat);
          bottle.position.copy(obj.position);
          bottle.position.y -= 0.6;
          scene.add(bottle);

          setStatus("ØªÙ… Ø£Ø®Ø° Drain Sample Ù…Ù† Ø®Ø· Ø§Ù„Ù€ Hook-Up Ø¨Ù†Ø¬Ø§Ø­.", "#9effc0");
          completeTraining();
        } else {
          setStatus("Ø§Ù„Ø¹ÙŠÙ†Ø© Ù…Ø£Ø®ÙˆØ°Ø© Ø¨Ø§Ù„ÙØ¹Ù„ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ø¯ÙˆØ±Ø©.", "#cccccc");
        }
        return;
      }
    }

    function onWindowResize() {
      if (!camera || !renderer) return;
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      if (controls && renderer && scene && camera) {
        controls.update();
        renderer.render(scene, camera);
      }
    }

    window.addEventListener("load", function () {
      if (typeof THREE === "undefined" || typeof THREE.OrbitControls === "undefined") {
        debugMsg.style.display = "block";
        debugMsg.textContent = "Three.js Ø£Ùˆ OrbitControls Ù„Ù… ÙŠØªÙ… ØªØ­Ù…ÙŠÙ„Ù‡Ù…Ø§.";
        return;
      }
      try {
        initScene();
        animate();
      } catch (e) {
        debugMsg.style.display = "block";
        debugMsg.textContent = "Ø­Ø¯Ø« Ø®Ø·Ø£ ÙÙŠ ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…Ø­Ø§ÙƒØ§Ø©: " + e.message;
      }
    });
  </script>
</body>
</html>
